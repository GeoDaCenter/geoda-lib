// generated by TSEMBIND

// define type aliases for various native number types
type Char = number;
type SignedChar = number;
type UnsignedChar = number;
type Short = number;
type UnsignedShort = number;
type Int = number;
type UnsignedInt = number;
type Long = number;
type UnsignedLong = number;
type Float = number;
type Double = number;

/**
 * Base class for geometry collections
 */
export class GeometryCollection {
  /**
   * Constructor for the base geometry collection class
   */
  constructor();
  delete(): void;
  getType(): number;
}

/**
 * PolygonCollection class.
 */
export class PolygonCollection extends GeometryCollection {
  /**
   * Constructor for the polygon collection class
   * @param xs VectorDouble Array of x coordinates
   * @param ys VectorDouble Array of y coordinates
   * @param parts VectorUInt Array of indices into xs/ys where each part starts
   * @param holes VectorUInt Array of indices into parts where each hole starts
   * @param sizes VectorUInt Array of number of parts for each feature
   * @param fixPolygon boolean Whether to fix polygon
   * @param convertToUTM boolean Whether to convert to UTM
   */
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    holes: VectorUInt,
    sizes: VectorUInt,
    fixPolygon: boolean,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

/**
 * LineCollection class.
 */
export class LineCollection extends GeometryCollection {
  /**
   * Constructor for the line collection class
   * @param xs VectorDouble Array of x coordinates
   * @param ys VectorDouble Array of y coordinates
   * @param parts VectorUInt Array of indices into xs/ys where each part starts
   * @param sizes VectorUInt Array of number of parts for each feature
   * @param convertToUTM boolean Whether to convert to UTM
   */
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

/**
 * Class representing a single point geometry
 */
export class Point {
  /**
   * Constructor for a single point geometry
   */
  constructor();
  /**
   * Get the x-coordinate of the point
   */
  getX(): VectorDouble;
  /**
   * Get the y-coordinate of the point
   */
  getY(): VectorDouble;
}

/**
 * PointCollection class.
 */
export class PointCollection extends GeometryCollection {
  /**
   * Constructor for the point collection class
   * @param xs VectorDouble Array of x coordinates
   * @param ys VectorDouble Array of y coordinates
   * @param parts VectorUInt Array of indices into xs/ys where each part starts
   * @param sizes VectorUInt Array of number of parts for each feature
   * @param convertToUTM boolean Whether to convert to UTM
   */
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

/**
 * Class representing a polygon geometry
 */
export class Polygon {
  /**
   * Constructor for the polygon class
   */
  constructor();
  /**
   * Get the x-coordinates of the polygon vertices
   */
  getX(): VectorDouble;
  /**
   * Get the y-coordinates of the polygon vertices
   */
  getY(): VectorDouble;
  /**
   * Get the indices of holes in the polygon
   */
  getHoles(): VectorUInt;
  /**
   * Get the indices where each part of the polygon starts
   */
  getParts(): VectorUInt;
  /**
   * Add a part to the polygon
   * @param arg0 Array of x coordinates
   * @param arg1 Array of y coordinates
   * @param arg2 Whether to fix the polygon
   */
  addPart(arg0: VectorDouble, arg1: VectorDouble, arg2: boolean): void;
  delete(): void;
}

/**
 * Vector class for unsigned integers
 */
export class VectorUInt {
  /**
   * Constructor for a vector of unsigned integers
   */
  constructor();
  /**
   * Add an element to the end of the vector
   * @param arg0 Element to add
   */
  push_back(arg0: UnsignedInt): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: UnsignedInt): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get element at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set element at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: UnsignedInt): boolean;
  delete(): void;
}

/**
 * Vector class for storing vectors of unsigned integers
 */
export class VecVecUInt {
  /**
   * Constructor for a vector of vectors of unsigned integers
   */
  constructor();
  /**
   * Add a vector to the end
   * @param arg0 Vector to add
   */
  push_back(arg0: VectorUInt): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: VectorUInt): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get vector at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set vector at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: VectorUInt): boolean;
  delete(): void;
}

/**
 * Vector class for integers
 */
export class VectorInt {
  /**
   * Constructor for a vector of integers
   */
  constructor();
  /**
   * Add an element to the end
   * @param arg0 Element to add
   */
  push_back(arg0: Int): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: Int): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get element at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set element at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: Int): boolean;
  delete(): void;
}

/**
 * Vector class for storing vectors of integers
 */
export class VecVecInt {
  /**
   * Constructor for a vector of vectors of integers
   */
  constructor();
  /**
   * Add a vector to the end
   * @param arg0 Vector to add
   */
  push_back(arg0: VectorInt): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: VectorInt): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get vector at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set vector at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: VectorInt): boolean;
  delete(): void;
}

/**
 * Vector class for double precision floating point numbers
 */
export class VectorDouble {
  /**
   * Constructor for a vector of double precision floating point numbers
   */
  constructor();
  /**
   * Add an element to the end
   * @param arg0 Element to add
   */
  push_back(arg0: Double): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: Double): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get element at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set element at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: Double): boolean;
  delete(): void;
}

/**
 * Vector class for storing vectors of doubles
 */
export class VecVecDouble {
  /**
   * Constructor for a vector of vectors of doubles
   */
  constructor();
  /**
   * Add a vector to the end
   * @param arg0 Vector to add
   */
  push_back(arg0: VectorDouble): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: VectorDouble): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get vector at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set vector at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: VectorDouble): boolean;
  delete(): void;
}

/**
 * Vector class for storing polygons
 */
export class VectorPolygon {
  /**
   * Constructor for a vector of polygons
   */
  constructor();
  /**
   * Add a polygon to the end
   * @param arg0 Polygon to add
   */
  push_back(arg0: Polygon): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: Polygon): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get polygon at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): any;
  /**
   * Set polygon at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: Polygon): boolean;
  delete(): void;
}

/**
 * Vector class for storing strings
 */
export class VectorString {
  /**
   * Constructor for a vector of strings
   */
  constructor();
  /**
   * Add a string to the end
   * @param arg0 String to add
   */
  push_back(arg0: string): void;
  /**
   * Resize the vector
   * @param arg0 New size
   * @param arg1 Value to fill new elements with
   */
  resize(arg0: UnsignedLong, arg1: string): void;
  /**
   * Get the size of the vector
   */
  size(): UnsignedLong;
  /**
   * Get string at index
   * @param arg0 Index
   */
  get(arg0: UnsignedLong): string;
  /**
   * Set string at index
   * @param arg0 Index
   * @param arg1 Value
   */
  set(arg0: UnsignedLong, arg1: string): boolean;
  delete(): void;
}

/**
 * Class representing results from LISA (Local Indicators of Spatial Association) analysis
 */
export class LisaResult {
  /**
   * Check if the result is valid
   */
  isValid(): boolean;
  /**
   * Get the p-values for each observation
   */
  getPValues(): VectorDouble;
  /**
   * Get the cluster assignments for each observation
   */
  getClusters(): VectorUInt;
  /**
   * Get the spatial lag values
   */
  getLagValues(): VectorDouble;
  /**
   * Get the LISA statistic values
   */
  getLisaValues(): VectorDouble;
  /**
   * Get the significance categories
   */
  getSignificanceCategories(): VectorInt;
  /**
   * Get the number of neighbors for each observation
   */
  getNN(): VectorInt;
  /**
   * Get the labels for the clusters
   */
  getLabels(): VectorString;
  /**
   * Get the colors associated with each cluster
   */
  getColors(): VectorString;
  delete(): void;
}

/**
 * Class for the diagnostic report of regression analysis
 */
export class DiagnosticReport {
  delete(): void;
  /**
   * Get the number of observations
   */
  GetNoObservation(): number;
  /**
   * Get the number of variables
   */
  GetNoVariable(): number;
  /**
   * Check if the constant is included
   */
  IncludeConstant(): boolean;
  /**
   * Get the name of the independent variable at index
   * @param i Index
   */
  GetXVarName(i: number): string;
  /**
   * Get the coefficient of the independent variable at index
   * @param i Index
   */
  GetCoefficient(i: number): Double;
  /**
   * Get the standard error of the independent variable at index
   * @param i Index
   */
  GetStdError(i: number): Double;
  /**
   * Get the z-value of the independent variable at index
   * @param i Index
   */
  GetZValue(i: number): Double;
  /**
   * Get the probability of the independent variable at index
   * @param i Index
   */
  GetProbability(i: number): Double;
  /**
   * Get the R-squared value
   */
  GetR2(): number;
  /**
   * Get the adjusted R-squared value
   */
  GetR2_adjust(): number;
  /**
   * Get the Buse R-squared value
   */
  GetR2_buse(): number;
  /**
   * Get the likelihood value
   */
  GetLIK(): number;
  /**
   * Get the Akaike Information Criterion (AIC) value
   */
  GetAIC(): number;
  /**
   * Get the OLS SC value
   */
  GetOLS_SC(): number;
  /**
   * Get the residual sum of squares (RSS) value
   */
  GetRSS(): number;
  /**
   * Get the Rho value
   */
  GetRho(): number;
  /**
   * Get the F-test value
   */
  GetFtest(): number;
  /**
   * Get the F-test probability value
   */
  GetFtestProb(): number;
  /**
   * Get the SIQ_SQ value
   */
  GetSIQ_SQ(): number;
  /**
   * Get the SIQ_SQLM value
   */
  GetSIQ_SQLM(): number;
  /**
   * Get the condition number
   */
  GetConditionNumber(): number;
  /**
   * Get the JB test value for the independent variable at index
   * @param i Index
   */
  GetJBtest(i: number): Double;
  /**
   * Get the BP test value for the independent variable at index
   * @param i Index
   */
  GetBPtest(i: number): Double;
  /**
   * Get the LR test value for the independent variable at index
   * @param i Index
   */
  GetLRTestValue(i: number): Double;
  /**
   * Get the Spatial BP test value for the independent variable at index
   * @param i Index
   */
  GetSpatialBPtest(i: number): Double;
  /**
   * Get the KB test value for the independent variable at index
   * @param i Index
   */
  GetKBtest(i: number): Double;
  /**
   * Get the white test value for the independent variable at index
   * @param i Index
   */
  GetWhitetest(i: number): Double;
  /**
   * Get the Moran I value for the independent variable at index
   * @param i Index
   */
  GetMoranI(i: number): Double;
  /**
   * Get the LMLAG value for the independent variable at index
   * @param i Index
   */
  GetLMLAG(i: number): Double;
  /**
   * Get the LMLAGRob value for the independent variable at index
   * @param i Index
   */
  GetLMLAGRob(i: number): Double;
  /**
   * Get the LMERR value for the independent variable at index
   * @param i Index
   */
  GetLMERR(i: number): Double;
  /**
   * Get the LMERRRob value for the independent variable at index
   * @param i Index
   */
  GetLMERRRob(i: number): Double;
  /**
   * Get the LMSarma value for the independent variable at index
   * @param i Index
   */
  GetLMSarma(i: number): Double;
  /**
   * Get the KelRobin value for the independent variable at index
   * @param i Index
   */
  GetKelRobin(i: number): Double;
  /**
   * Get the mean of the dependent variable
   */
  GetMeanY(): number;
  /**
   * Get the standard deviation of the dependent variable
   */
  GetSDevY(): number;
}

export interface GeoDaModule {
  /**
   * get the contiguity neighbors using the centroids of a collection of geometries
   * @param geometries
   * @param isQueen
   * @param precisionThreshold
   * @param orderOfContiguity
   * @param includeLowerOrder
   */
  getPointContiguityWeights(
    geometries: GeometryCollection,
    isQueen: boolean,
    precisionThreshold: number,
    orderOfContiguity: number,
    includeLowerOrder: boolean
  ): VecVecUInt;

  /**
   * get the contiguity neighbors of a collection of polygons
   * @param geometries
   * @param isQueen
   * @param precisionThreshold
   * @param orderOfContiguity
   * @param includeLowerOrder
   */
  getPolygonContiguityWeights(
    geometries: GeometryCollection,
    isQueen: boolean,
    precisionThreshold: number,
    orderOfContiguity: number,
    includeLowerOrder: boolean
  ): VecVecUInt;

  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param k the number of nearest neighbors
   */
  getNearestNeighbors(geometries: GeometryCollection, k: UnsignedInt): VecVecUInt;

  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param threshold the distance threshold
   * @param isMile the unit of distance
   */
  getDistanceWeights(
    geometries: GeometryCollection,
    threshold: Double,
    isMile: boolean
  ): VecVecUInt;

  /**
   * get the distance thresholds of a collection of geometries that guarantee 1 nearest neighbors
   * @param geometries the collection of geometries
   * @param isMile the unit of distance
   */
  getDistanceThresholds(geometries: GeometryCollection, isMile: boolean): VectorDouble;

  /**
   *
   * @param k the number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  quantileBreaks(k: number, data: VectorDouble, undefs?: VectorUInt): VectorDouble;

  /**
   * Natural Jenks breaks classification
   * @param k number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  naturalBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Equal interval breaks classification
   * @param k number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the flags of undefined values
   */
  equalIntervalBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Percentile breaks classification: <1%, 1-10%, 10-50%, 50-90%, 90-99%, >99%
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   */
  percentileBreaks(data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Box breaks classification: Lower outlier, < 25%, [25-50)%, [50-75)%, >= 75%, Upper outlier
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   * @param hinge the hinge value, default is 1.5 and could be 3.0
   */
  boxBreaks(data: VectorDouble, undefs: VectorInt, hinge: Double): VectorDouble;

  /**
   * Standard deviation breaks classification
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   */
  standardDeviationBreaks(data: VectorDouble, undefs: VectorInt): VectorDouble;

  /**
   * Local Moran statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  localMoran(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Bivariate Local Moran statistics
   * @param data1 the first data values
   * @param data2 the second data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  bivariateLocalMoran(
    data1: VectorDouble,
    data2: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Local Getis-Ord statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   * @param isGStar whether to use G* or G
   */
  localG(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number,
    isGStar: number
  ): LisaResult;

  /**
   * Local Geary statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  localGeary(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Multivariate Local Geary statistics
   * @param data the array of data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the array of undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  multivariateLocalGeary(
    data: VecVecDouble,
    neighbors: VecVecUInt,
    undefs: VecVecUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Local Quantile LISA statistics
   * @param k the number of breaks
   * @param quantile which quantile to use
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  quantileLisa(
    k: number,
    quantile: number,
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  // test for dotProduct
  dotProduct(x: VectorDouble, y: VectorDouble): number;

  /**
   *
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  linearRegression(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Lag regression
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  spatialLag(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Error regression
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  spatialError(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Join of two collections of geometries
   * @param left The left collection of geometries
   * @param right The right collection of geometries
   * @returns The indices of the right geometries that are spatially joined to the left geometries
   */
  spatialJoin(
    left: GeometryCollection,
    right: GeometryCollection
  ): VecVecUInt;

  GeometryCollection: typeof GeometryCollection;
  PolygonCollection: typeof PolygonCollection;
  LineCollection: typeof LineCollection;
  PointCollection: typeof PointCollection;
  Polygon: typeof Polygon;
  VectorUInt: typeof VectorUInt;
  VecVecUInt: typeof VecVecUInt;
  VectorInt: typeof VectorInt;
  VecVecInt: typeof VecVecInt;
  VectorDouble: typeof VectorDouble;
  VecVecDouble: typeof VecVecDouble;
  VectorPolygon: typeof VectorPolygon;
  VectorString: typeof VectorString;
  LisaResult: typeof LisaResult;
  DiagnosticReport: typeof DiagnosticReport;
}
declare function factory(): Promise<GeoDaModule>;
export default factory;
