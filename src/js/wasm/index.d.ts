// generated by TSEMBIND

// define type aliases for various native number types
type Char = number;
type SignedChar = number;
type UnsignedChar = number;
type Short = number;
type UnsignedShort = number;
type Int = number;
type UnsignedInt = number;
type Long = number;
type UnsignedLong = number;
type Float = number;
type Double = number;

export class GeometryCollection {
  delete(): void;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param holes VectorUInt Array of indices into parts where each hole starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param fixPolygon boolean Whether to fix polygon
 * @param convertToUTM boolean Whether to convert to UTM
 * @returns PolygonCollection
 */
export class PolygonCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    holes: VectorUInt,
    sizes: VectorUInt,
    fixPolygon: boolean,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param convertToUTM boolean Whether to convert to UTM
 */
export class LineCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

export class Point {
  constructor();
  getX(): VectorDouble;
  getY(): VectorDouble;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param convertToUTM boolean Whether to convert to UTM
 */
export class PointCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

export class Polygon {
  constructor();

  getX(): VectorDouble;

  getY(): VectorDouble;

  getHoles(): VectorUInt;

  getParts(): VectorUInt;

  addPart(arg0: VectorDouble, arg1: VectorDouble, arg2: boolean): void;
  delete(): void;
}

export class VectorUInt {
  constructor();

  push_back(arg0: UnsignedInt): void;

  resize(arg0: UnsignedLong, arg1: UnsignedInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: UnsignedInt): boolean;
  delete(): void;
}

export class VecVecUInt {
  constructor();

  push_back(arg0: VectorUInt): void;

  resize(arg0: UnsignedLong, arg1: VectorUInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorUInt): boolean;
  delete(): void;
}

export class VectorInt {
  constructor();

  push_back(arg0: Int): void;

  resize(arg0: UnsignedLong, arg1: Int): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Int): boolean;
  delete(): void;
}

export class VecVecInt {
  constructor();

  push_back(arg0: VectorInt): void;

  resize(arg0: UnsignedLong, arg1: VectorInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorInt): boolean;
  delete(): void;
}

export class VectorDouble {
  constructor();

  push_back(arg0: Double): void;

  resize(arg0: UnsignedLong, arg1: Double): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Double): boolean;
  delete(): void;
}

export class VecVecDouble {
  constructor();

  push_back(arg0: VectorDouble): void;

  resize(arg0: UnsignedLong, arg1: VectorDouble): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorDouble): boolean;
  delete(): void;
}

export class VectorPolygon {
  constructor();

  push_back(arg0: Polygon): void;

  resize(arg0: UnsignedLong, arg1: Polygon): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Polygon): boolean;
  delete(): void;
}

export class VectorString {
  constructor();

  push_back(arg0: string): void;

  resize(arg0: UnsignedLong, arg1: string): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): string;

  set(arg0: UnsignedLong, arg1: string): boolean;
  delete(): void;
}

export class LisaResult {
  isValid(): boolean;

  getPValues(): VectorDouble;

  getClusters(): VectorUInt;

  getLagValues(): VectorDouble;

  getLisaValues(): VectorDouble;

  getSignificanceCategories(): VectorInt;

  getNN(): VectorInt;

  getLabels(): VectorString;

  getColors(): VectorString;

  delete(): void;
}

/**
 * Class for the diagnostic report of regression analysis
 */
export class DiagnosticReport {
  delete(): void;
  GetNoObservation(): number;
  GetNoVariable(): number;
  IncludeConstant(): boolean;
  GetXVarName(i: number): string;
  GetCoefficient(i: number): Double;
  GetStdError(i: number): Double;
  GetZValue(i: number): Double;
  GetProbability(i: number): Double;
  GetR2(): number;
  GetR2_adjust(): number;
  GetR2_buse(): number;
  GetLIK(): number;
  GetAIC(): number;
  GetOLS_SC(): number;
  GetRSS(): number;
  GetRho(): number;
  GetFtest(): number;
  GetFtestProb(): number;
  GetSIQ_SQ(): number;
  GetSIQ_SQLM(): number;
  GetConditionNumber(): number;
  GetJBtest(i: number): Double;
  GetBPtest(i: number): Double;
  GetLRTestValue(i: number): Double;
  GetSpatialBPtest(i: number): Double;
  GetKBtest(i: number): Double;
  GetWhitetest(i: number): Double;
  GetMoranI(i: number): Double;
  GetLMLAG(i: number): Double;
  GetLMLAGRob(i: number): Double;
  GetLMERR(i: number): Double;
  GetLMERRRob(i: number): Double;
  GetLMSarma(i: number): Double;
  GetKelRobin(i: number): Double;
  GetMeanY(): number;
  GetSDevY(): number;
}

export interface GeoDaModule {
  /**
   * get the contiguity neighbors using the centroids of a collection of geometries
   * @param geometries
   * @param isQueen
   * @param precisionThreshold
   * @param orderOfContiguity
   * @param includeLowerOrder
   */
  getPointContiguityWeights(
    geometries: GeometryCollection,
    isQueen: boolean,
    precisionThreshold: number,
    orderOfContiguity: number,
    includeLowerOrder: boolean
  ): VecVecUInt;

  /**
   * get the contiguity neighbors of a collection of polygons
   * @param geometries
   * @param isQueen
   * @param precisionThreshold
   * @param orderOfContiguity
   * @param includeLowerOrder
   */
  getPolygonContiguityWeights(
    geometries: GeometryCollection,
    isQueen: boolean,
    precisionThreshold: number,
    orderOfContiguity: number,
    includeLowerOrder: boolean
  ): VecVecUInt;

  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param k the number of nearest neighbors
   */
  getNearestNeighbors(geometries: GeometryCollection, k: UnsignedInt): VecVecUInt;

  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param threshold the distance threshold
   * @param isMile the unit of distance
   */
  getDistanceWeights(
    geometries: GeometryCollection,
    threshold: Double,
    isMile: boolean
  ): VecVecUInt;

  /**
   * get the distance thresholds of a collection of geometries that guarantee 1 nearest neighbors
   * @param geometries the collection of geometries
   * @param isMile the unit of distance
   */
  getDistanceThresholds(geometries: GeometryCollection, isMile: boolean): VectorDouble;

  /**
   *
   * @param k the number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  quantileBreaks(k: number, data: VectorDouble, undefs?: VectorUInt): VectorDouble;

  /**
   * Natural Jenks breaks classification
   * @param k number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  naturalBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Equal interval breaks classification
   * @param k number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the flags of undefined values
   */
  equalIntervalBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Percentile breaks classification: <1%, 1-10%, 10-50%, 50-90%, 90-99%, >99%
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   */
  percentileBreaks(data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Box breaks classification: Lower outlier, < 25%, [25-50)%, [50-75)%, >= 75%, Upper outlier
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   * @param hinge the hinge value, default is 1.5 and could be 3.0
   */
  boxBreaks(data: VectorDouble, undefs: VectorInt, hinge: Double): VectorDouble;

  /**
   * Standard deviation breaks classification
   * @param data the values to be classified
   * @param undefs the flags of undefined values
   */
  standardDeviationBreaks(data: VectorDouble, undefs: VectorInt): VectorDouble;

  /**
   * Local Moran statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  localMoran(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Bivariate Local Moran statistics
   * @param data1 the first data values
   * @param data2 the second data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  bivariateLocalMoran(
    data1: VectorDouble,
    data2: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Local Getis-Ord statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   * @param isGStar whether to use G* or G
   */
  localG(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number,
    isGStar: number
  ): LisaResult;

  /**
   * Local Geary statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  localGeary(
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Multivariate Local Geary statistics
   * @param data the array of data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the array of undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  multivariateLocalGeary(
    data: VecVecDouble,
    neighbors: VecVecUInt,
    undefs: VecVecUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  /**
   * Local Quantile LISA statistics
   * @param k the number of breaks
   * @param quantile which quantile to use
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param undefs the undefined values
   * @param significanceCutoff the significance cutoff
   * @param permuations the number of permutations
   * @param lastSeed the last seed
   */
  quantileLisa(
    k: number,
    quantile: number,
    data: VectorDouble,
    neighbors: VecVecUInt,
    undefs: VectorUInt,
    significanceCutoff: number,
    permuations: UnsignedInt,
    lastSeed: number
  ): LisaResult;

  // test for dotProduct
  dotProduct(x: VectorDouble, y: VectorDouble): number;

  /**
   *
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  linearRegression(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Lag regression
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  spatialLag(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Error regression
   * @param dep The values of the dependent variable
   * @param indeps The values of the independent variables, it's a 2D array
   * @param weights The spatial weights represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param weightsValues The spatial weights values represented as a 2D array and each row shows the neighbors of the corresponding observation
   * @param depName The name of the dependent variable
   * @param indepNames The names of the independent variables
   * @param datasetName The name of the dataset
   * @param depUndefs The 0/1 array indicating the undefined values of the dependent variable
   * @param indepUndefs The 2D array of 0/1 indicating the undefined values of the independent variables
   */
  spatialError(
    dep: VectorDouble,
    indeps: VecVecDouble,
    weights: VecVecUInt,
    weightsValues: VecVecDouble,
    depName: string,
    indepNames: VectorString,
    datasetName: string,
    depUndefs: VectorUInt,
    indepUndefs: VecVecUInt
  ): DiagnosticReport;

  /**
   * Spatial Join of two collections of geometries
   * @param left The left collection of geometries
   * @param right The right collection of geometries
   * @returns The indices of the right geometries that are spatially joined to the left geometries
   */
  spatialJoin(
    left: GeometryCollection,
    right: GeometryCollection
  ): VecVecUInt;

  GeometryCollection: typeof GeometryCollection;
  PolygonCollection: typeof PolygonCollection;
  LineCollection: typeof LineCollection;
  PointCollection: typeof PointCollection;
  Polygon: typeof Polygon;
  VectorUInt: typeof VectorUInt;
  VecVecUInt: typeof VecVecUInt;
  VectorInt: typeof VectorInt;
  VecVecInt: typeof VecVecInt;
  VectorDouble: typeof VectorDouble;
  VecVecDouble: typeof VecVecDouble;
  VectorPolygon: typeof VectorPolygon;
  VectorString: typeof VectorString;
  LisaResult: typeof LisaResult;
  DiagnosticReport: typeof DiagnosticReport;
}
declare function factory(): Promise<GeoDaModule>;
export default factory;
