// generated by TSEMBIND

// define type aliases for various native number types
type Char = number;
type SignedChar = number;
type UnsignedChar = number;
type Short = number;
type UnsignedShort = number;
type Int = number;
type UnsignedInt = number;
type Long = number;
type UnsignedLong = number;
type Float = number;
type Double = number;

export class GeometryCollection {
  delete(): void;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param holes VectorUInt Array of indices into parts where each hole starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param fixPolygon boolean Whether to fix polygon
 * @param convertToUTM boolean Whether to convert to UTM
 * @returns PolygonCollection
 */
export class PolygonCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    holes: VectorUInt,
    sizes: VectorUInt,
    fixPolygon: boolean,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param convertToUTM boolean Whether to convert to UTM
 */
export class LineCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

export class Point {
  constructor();
  getX(): VectorDouble;
  getY(): VectorDouble;
}

/**
 * @param xs VectorDouble Array of x coordinates
 * @param ys VectorDouble Array of y coordinates
 * @param parts VectorUInt Array of indices into xs/ys where each part starts
 * @param sizes VectorUInt Array of number of parts for each feature
 * @param convertToUTM boolean Whether to convert to UTM
 */
export class PointCollection extends GeometryCollection {
  constructor(
    xs: VectorDouble,
    ys: VectorDouble,
    parts: VectorUInt,
    sizes: VectorUInt,
    convertToUTM: boolean
  );

  getCentroids(): VecVecDouble;
  delete(): void;
}

export class Polygon {
  constructor();

  getX(): VectorDouble;

  getY(): VectorDouble;

  getHoles(): VectorUInt;

  getParts(): VectorUInt;

  addPart(arg0: VectorDouble, arg1: VectorDouble, arg2: boolean): void;
  delete(): void;
}

export class VectorUInt {
  constructor();

  push_back(arg0: UnsignedInt): void;

  resize(arg0: UnsignedLong, arg1: UnsignedInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: UnsignedInt): boolean;
  delete(): void;
}

export class VecVecUInt {
  constructor();

  push_back(arg0: VectorUInt): void;

  resize(arg0: UnsignedLong, arg1: VectorUInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorUInt): boolean;
  delete(): void;
}

export class VectorInt {
  constructor();

  push_back(arg0: Int): void;

  resize(arg0: UnsignedLong, arg1: Int): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Int): boolean;
  delete(): void;
}

export class VecVecInt {
  constructor();

  push_back(arg0: VectorInt): void;

  resize(arg0: UnsignedLong, arg1: VectorInt): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorInt): boolean;
  delete(): void;
}

export class VectorDouble {
  constructor();

  push_back(arg0: Double): void;

  resize(arg0: UnsignedLong, arg1: Double): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Double): boolean;
  delete(): void;
}

export class VecVecDouble {
  constructor();

  push_back(arg0: VectorDouble): void;

  resize(arg0: UnsignedLong, arg1: VectorDouble): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: VectorDouble): boolean;
  delete(): void;
}

export class VectorPolygon {
  constructor();

  push_back(arg0: Polygon): void;

  resize(arg0: UnsignedLong, arg1: Polygon): void;

  size(): UnsignedLong;

  get(arg0: UnsignedLong): any;

  set(arg0: UnsignedLong, arg1: Polygon): boolean;
  delete(): void;
}

export class LisaResult {
  isValid(): boolean;

  getPValues(): VectorDouble;

  getClusters(): VectorUInt;

  getLagValues(): VectorDouble;

  getLisaValues(): VectorDouble;
  delete(): void;
}

export interface GeoDaModule {
  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param k the number of nearest neighbors
   */
  getNearestNeighbors(geometries: GeometryCollection, k: UnsignedInt): VecVecUInt;

  /**
   * get the nearest neighbors of a collection of geometries
   * @param geometries the collection of geometries
   * @param threshold the distance threshold
   * @param isMile the unit of distance
   */
  getDistanceWeights(
    geometries: GeometryCollection,
    threshold: Double,
    isMile: boolean
  ): VecVecUInt;

  /**
   * get the distance thresholds of a collection of geometries that guarantee 1 nearest neighbors
   * @param geometries the collection of geometries
   * @param isMile the unit of distance
   */
  getDistanceThresholds(geometries: GeometryCollection, isMile: boolean): VectorDouble;

  /**
   * 
   * @param k the number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  quantileBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Natural Jenks breaks classification
   * @param k number of breaks
   * @param data the values to be classified into k classes
   * @param undefs the indices of data that are undefined
   */
  naturalBreaks(k: number, data: VectorDouble, undefs?: VectorInt): VectorDouble;

  /**
   * Local Moran statistics
   * @param data the data values
   * @param neighbors the spatial weights matrix that represents neighbor indices: [[1, 2], [0, 2], [0, 1],...]
   * @param permuations the number of permutations
   */
  localMoran(data: VectorDouble, neighbors: VecVecUInt, permuations: UnsignedInt): LisaResult;

  GeometryCollection: typeof GeometryCollection;
  PolygonCollection: typeof PolygonCollection;
  LineCollection: typeof LineCollection;
  PointCollection: typeof PointCollection;
  Polygon: typeof Polygon;
  VectorUInt: typeof VectorUInt;
  VecVecUInt: typeof VecVecUInt;
  VectorInt: typeof VectorInt;
  VecVecInt: typeof VecVecInt;
  VectorDouble: typeof VectorDouble;
  VecVecDouble: typeof VecVecDouble;
  VectorPolygon: typeof VectorPolygon;
  LisaResult: typeof LisaResult;
}
declare function factory(): Promise<GeoDaModule>;
export default factory;
