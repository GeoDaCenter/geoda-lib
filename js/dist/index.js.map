{
  "version": 3,
  "sources": ["../wasm/index.cjs", "../src/init.ts", "../src/features/geometry.ts", "../src/operations/centroids.ts", "../src/weights/distance-based-neighbors.ts", "../src/utils.ts", "../src/operations/buffer.ts", "../src/operations/join.ts", "../src/operations/parallel-join-utils.ts", "../src/operations/parallel-join.ts", "../src/operations/union.ts", "../src/operations/count.ts", "../src/weights/nearest-neighbors.ts", "../src/statistics/local-moran.ts"],
  "sourcesContent": ["var geoda = (() => {\n  var _scriptDir =\n    typeof document !== 'undefined' && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\n  return function (moduleArg = {}) {\n    var Module = moduleArg;\n    var readyPromiseResolve, readyPromiseReject;\n    Module['ready'] = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = Object.assign({}, Module);\n    var arguments_ = [];\n    var thisProgram = './this.program';\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = typeof window == 'object';\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n    var ENVIRONMENT_IS_NODE =\n      typeof process == 'object' &&\n      typeof process.versions == 'object' &&\n      typeof process.versions.node == 'string';\n    var scriptDirectory = '';\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary, setWindowTitle;\n    if (ENVIRONMENT_IS_NODE) {\n      var fs = require('fs');\n      var nodePath = require('path');\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = nodePath.dirname(scriptDirectory) + '/';\n      } else {\n        scriptDirectory = __dirname + '/';\n      }\n      read_ = (filename, binary) => {\n        filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n        return fs.readFileSync(filename, binary ? undefined : 'utf8');\n      };\n      readBinary = filename => {\n        var ret = read_(filename, true);\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n        return ret;\n      };\n      readAsync = (filename, onload, onerror, binary = true) => {\n        filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n        fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\n          if (err) onerror(err);\n          else onload(binary ? data.buffer : data);\n        });\n      };\n      if (!Module['thisProgram'] && process.argv.length > 1) {\n        thisProgram = process.argv[1].replace(/\\\\/g, '/');\n      }\n      arguments_ = process.argv.slice(2);\n      quit_ = (status, toThrow) => {\n        process.exitCode = status;\n        throw toThrow;\n      };\n      Module['inspect'] = () => '[Emscripten Module object]';\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1\n        );\n      } else {\n        scriptDirectory = '';\n      }\n      {\n        read_ = url => {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = url => {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n        readAsync = (url, onload, onerror) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, true);\n          xhr.responseType = 'arraybuffer';\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n      setWindowTitle = title => (document.title = title);\n    } else {\n    }\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.error.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    if (Module['arguments']) arguments_ = Module['arguments'];\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n    if (Module['quit']) quit_ = Module['quit'];\n    var wasmBinary;\n    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n    var noExitRuntime = Module['noExitRuntime'] || true;\n    if (typeof WebAssembly != 'object') {\n      abort('no native wasm support detected');\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n    }\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n      what = 'Aborted(' + what + ')';\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += '. Build with -sASSERTIONS for more info.';\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    function isFileURI(filename) {\n      return filename.startsWith('file://');\n    }\n    var wasmBinaryFile;\n    wasmBinaryFile = '../../../geoda.wasm';\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch == 'function' && !isFileURI(binaryFile)) {\n          return fetch(binaryFile, {credentials: 'same-origin'})\n            .then(response => {\n              if (!response['ok']) {\n                throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n              }\n              return response['arrayBuffer']();\n            })\n            .catch(() => getBinarySync(binaryFile));\n        } else if (readAsync) {\n          return new Promise((resolve, reject) => {\n            readAsync(binaryFile, response => resolve(new Uint8Array(response)), reject);\n          });\n        }\n      }\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then(binary => WebAssembly.instantiate(binary, imports))\n        .then(instance => instance)\n        .then(receiver, reason => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n          abort(reason);\n        });\n    }\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (\n        !binary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(binaryFile) &&\n        !isFileURI(binaryFile) &&\n        !ENVIRONMENT_IS_NODE &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(binaryFile, {credentials: 'same-origin'}).then(response => {\n          var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function (reason) {\n            err(`wasm streaming compile failed: ${reason}`);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n    function createWasm() {\n      var info = {a: wasmImports};\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        exports = applySignatureConversions(exports);\n        wasmExports = exports;\n        wasmMemory = wasmExports['x'];\n        updateMemoryViews();\n        wasmTable = wasmExports['z'];\n        addOnInit(wasmExports['y']);\n        removeRunDependency('wasm-instantiate');\n        return exports;\n      }\n      addRunDependency('wasm-instantiate');\n      function receiveInstantiationResult(result) {\n        receiveInstance(result['instance']);\n      }\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          readyPromiseReject(e);\n        }\n      }\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(\n        readyPromiseReject\n      );\n      return {};\n    }\n    var callRuntimeCallbacks = callbacks => {\n      while (callbacks.length > 0) {\n        callbacks.shift()(Module);\n      }\n    };\n    var exceptionCaught = [];\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    var ___cxa_rethrow = () => {\n      var info = exceptionCaught.pop();\n      if (!info) {\n        abort('no exception to throw');\n      }\n      var ptr = info.excPtr;\n      if (!info.get_rethrown()) {\n        exceptionCaught.push(info);\n        info.set_rethrown(true);\n        info.set_caught(false);\n        uncaughtExceptionCount++;\n      }\n      exceptionLast = ptr;\n      throw exceptionLast;\n    };\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 24;\n      this.set_type = function (type) {\n        HEAPU32[((this.ptr + 4) >>> 2) >>> 0] = type;\n      };\n      this.get_type = function () {\n        return HEAPU32[((this.ptr + 4) >>> 2) >>> 0];\n      };\n      this.set_destructor = function (destructor) {\n        HEAPU32[((this.ptr + 8) >>> 2) >>> 0] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAPU32[((this.ptr + 8) >>> 2) >>> 0];\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[((this.ptr + 12) >>> 0) >>> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[((this.ptr + 12) >>> 0) >>> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[((this.ptr + 13) >>> 0) >>> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[((this.ptr + 13) >>> 0) >>> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n      };\n      this.set_adjusted_ptr = function (adjustedPtr) {\n        HEAPU32[((this.ptr + 16) >>> 2) >>> 0] = adjustedPtr;\n      };\n      this.get_adjusted_ptr = function () {\n        return HEAPU32[((this.ptr + 16) >>> 2) >>> 0];\n      };\n      this.get_exception_ptr = function () {\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\n        if (isPointer) {\n          return HEAPU32[(this.excPtr >>> 2) >>> 0];\n        }\n        var adjusted = this.get_adjusted_ptr();\n        if (adjusted !== 0) return adjusted;\n        return this.excPtr;\n      };\n    }\n    function ___cxa_throw(ptr, type, destructor) {\n      ptr >>>= 0;\n      type >>>= 0;\n      destructor >>>= 0;\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw exceptionLast;\n    }\n    function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {\n      primitiveType >>>= 0;\n      name >>>= 0;\n      size >>>= 0;\n    }\n    var embind_init_charCodes = () => {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    };\n    var embind_charCodes = undefined;\n    var readLatin1String = ptr => {\n      var ret = '';\n      var c = ptr;\n      while (HEAPU8[c >>> 0]) {\n        ret += embind_charCodes[HEAPU8[c++ >>> 0]];\n      }\n      return ret;\n    };\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var BindingError = undefined;\n    var throwBindingError = message => {\n      throw new BindingError(message);\n    };\n    var InternalError = undefined;\n    var throwInternalError = message => {\n      throw new InternalError(message);\n    };\n    var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError('Mismatched type converter count');\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach((dt, i) => {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(() => {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    };\n    function sharedRegisterType(rawType, registeredInstance, options = {}) {\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(`Cannot register type '${name}' twice`);\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(cb => cb());\n      }\n    }\n    function registerType(rawType, registeredInstance, options = {}) {\n      if (!('argPackAdvance' in registeredInstance)) {\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n      return sharedRegisterType(rawType, registeredInstance, options);\n    }\n    var GenericWireTypeSize = 8;\n    function __embind_register_bool(rawType, name, trueValue, falseValue) {\n      rawType >>>= 0;\n      name >>>= 0;\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (wt) {\n          return !!wt;\n        },\n        toWireType: function (destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: function (pointer) {\n          return this['fromWireType'](HEAPU8[pointer >>> 0]);\n        },\n        destructorFunction: null\n      });\n    }\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n      return leftClass === rightClass && left === right;\n    }\n    var shallowCopyInternalPointer = o => ({\n      count: o.count,\n      deleteScheduled: o.deleteScheduled,\n      preservePointerOnDelete: o.preservePointerOnDelete,\n      ptr: o.ptr,\n      ptrType: o.ptrType,\n      smartPtr: o.smartPtr,\n      smartPtrType: o.smartPtrType\n    });\n    var throwInstanceAlreadyDeleted = obj => {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    };\n    var finalizationRegistry = false;\n    var detachFinalizer = handle => {};\n    var runDestructor = $$ => {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    };\n    var releaseClassHandle = $$ => {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    };\n    var downcastPointer = (ptr, ptrClass, desiredClass) => {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    };\n    var registeredPointers = {};\n    var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;\n    var getLiveInheritedInstances = () => {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    };\n    var deletionQueue = [];\n    var flushPendingDeletes = () => {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj['delete']();\n      }\n    };\n    var delayFunction = undefined;\n    var setDelayFunction = fn => {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    };\n    var init_embind = () => {\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\n      Module['flushPendingDeletes'] = flushPendingDeletes;\n      Module['setDelayFunction'] = setDelayFunction;\n    };\n    var registeredInstances = {};\n    var getBasestPointer = (class_, ptr) => {\n      if (ptr === undefined) {\n        throwBindingError('ptr should not be undefined');\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    };\n    var getInheritedInstance = (class_, ptr) => {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    };\n    var makeClassHandle = (prototype, record) => {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n      record.count = {value: 1};\n      return attachFinalizer(Object.create(prototype, {$$: {value: record}}));\n    };\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance['clone']();\n        } else {\n          var rv = registeredInstance['clone']();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {ptrType: this, ptr: ptr});\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n    var attachFinalizer = handle => {\n      if ('undefined' === typeof FinalizationRegistry) {\n        attachFinalizer = handle => handle;\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry(info => {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = handle => {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          var info = {$$: $$};\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = handle => finalizationRegistry.unregister(handle);\n      return attachFinalizer(handle);\n    };\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(\n          Object.create(Object.getPrototypeOf(this), {\n            $$: {value: shallowCopyInternalPointer(this.$$)}\n          })\n        );\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n    var init_ClassHandle = () => {\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\n    };\n    function ClassHandle() {}\n    var char_0 = 48;\n    var char_9 = 57;\n    var makeLegalFunctionName = name => {\n      if (undefined === name) {\n        return '_unknown';\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return `_${name}`;\n      }\n      return name;\n    };\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return {\n        [name]: function () {\n          return body.apply(this, arguments);\n        }\n      }[name];\n    }\n    var ensureOverloadTable = (proto, methodName, humanName) => {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\n              `Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`\n            );\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    };\n    var exposePublicSymbol = (name, value, numArguments) => {\n      if (Module.hasOwnProperty(name)) {\n        if (\n          undefined === numArguments ||\n          (undefined !== Module[name].overloadTable &&\n            undefined !== Module[name].overloadTable[numArguments])\n        ) {\n          throwBindingError(`Cannot register public name '${name}' twice`);\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\n            `Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`\n          );\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    };\n    function RegisteredClass(\n      name,\n      constructor,\n      instancePrototype,\n      rawDestructor,\n      baseClass,\n      getActualType,\n      upcast,\n      downcast\n    ) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n    var upcastPointer = (ptr, ptrClass, desiredClass) => {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\n            `Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`\n          );\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    };\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\n          `Cannot convert argument of type ${\n            handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name\n          } to parameter type ${this.name}`\n        );\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\n                `Cannot convert argument of type ${\n                  handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name\n                } to parameter type ${this.name}`\n              );\n            }\n            break;\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle['clone']();\n              ptr = this.rawShare(\n                ptr,\n                Emval.toHandle(() => clonedHandle['delete']())\n              );\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n          default:\n            throwBindingError('Unsupporting sharing policy');\n        }\n      }\n      return ptr;\n    }\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\n          `Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`\n        );\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n    function readPointer(pointer) {\n      return this['fromWireType'](HEAPU32[(pointer >>> 2) >>> 0]);\n    }\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n    var RegisteredPointer_deleteObject = handle => {\n      if (handle !== null) {\n        handle['delete']();\n      }\n    };\n    var init_RegisteredPointer = () => {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype['argPackAdvance'] = GenericWireTypeSize;\n      RegisteredPointer.prototype['readValueFromPointer'] = readPointer;\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\n    };\n    function RegisteredPointer(\n      name,\n      registeredClass,\n      isReference,\n      isConst,\n      isSmartPointer,\n      pointeeType,\n      sharingPolicy,\n      rawGetPointee,\n      rawConstructor,\n      rawShare,\n      rawDestructor\n    ) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this['toWireType'] = genericPointerToWireType;\n      }\n    }\n    var replacePublicSymbol = (name, value, numArguments) => {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError('Replacing nonexistant public symbol');\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    };\n    var dynCallLegacy = (sig, ptr, args) => {\n      var f = Module['dynCall_' + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    };\n    var wasmTableMirror = [];\n    var getWasmTableEntry = funcPtr => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    };\n    var dynCall = (sig, ptr, args) => {\n      if (sig.includes('j')) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      var rtn = getWasmTableEntry(ptr).apply(null, args);\n      return rtn;\n    };\n    var getDynCaller = (sig, ptr) => {\n      var argCache = [];\n      return function () {\n        argCache.length = 0;\n        Object.assign(argCache, arguments);\n        return dynCall(sig, ptr, argCache);\n      };\n    };\n    var embind__requireFunction = (signature, rawFunction) => {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes('j')) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp != 'function') {\n        throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n      }\n      return fp;\n    };\n    var extendError = (baseErrorType, errorName) => {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + '\\n' + stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return `${this.name}: ${this.message}`;\n        }\n      };\n      return errorClass;\n    };\n    var UnboundTypeError = undefined;\n    var getTypeName = type => {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    };\n    var throwUnboundTypeError = (message, types) => {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));\n    };\n    function __embind_register_class(\n      rawType,\n      rawPointerType,\n      rawConstPointerType,\n      baseClassRawType,\n      getActualTypeSignature,\n      getActualType,\n      upcastSignature,\n      upcast,\n      downcastSignature,\n      downcast,\n      name,\n      destructorSignature,\n      rawDestructor\n    ) {\n      rawType >>>= 0;\n      rawPointerType >>>= 0;\n      rawConstPointerType >>>= 0;\n      baseClassRawType >>>= 0;\n      getActualTypeSignature >>>= 0;\n      getActualType >>>= 0;\n      upcastSignature >>>= 0;\n      upcast >>>= 0;\n      downcastSignature >>>= 0;\n      downcast >>>= 0;\n      name >>>= 0;\n      destructorSignature >>>= 0;\n      rawDestructor >>>= 0;\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved(\n        [rawType, rawPointerType, rawConstPointerType],\n        baseClassRawType ? [baseClassRawType] : [],\n        function (base) {\n          base = base[0];\n          var baseClass;\n          var basePrototype;\n          if (baseClassRawType) {\n            baseClass = base.registeredClass;\n            basePrototype = baseClass.instancePrototype;\n          } else {\n            basePrototype = ClassHandle.prototype;\n          }\n          var constructor = createNamedFunction(legalFunctionName, function () {\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\n              throw new BindingError(\"Use 'new' to construct \" + name);\n            }\n            if (undefined === registeredClass.constructor_body) {\n              throw new BindingError(name + ' has no accessible constructor');\n            }\n            var body = registeredClass.constructor_body[arguments.length];\n            if (undefined === body) {\n              throw new BindingError(\n                `Tried to invoke ctor of ${name} with invalid number of parameters (${\n                  arguments.length\n                }) - expected (${Object.keys(\n                  registeredClass.constructor_body\n                ).toString()}) parameters instead!`\n              );\n            }\n            return body.apply(this, arguments);\n          });\n          var instancePrototype = Object.create(basePrototype, {constructor: {value: constructor}});\n          constructor.prototype = instancePrototype;\n          var registeredClass = new RegisteredClass(\n            name,\n            constructor,\n            instancePrototype,\n            rawDestructor,\n            baseClass,\n            getActualType,\n            upcast,\n            downcast\n          );\n          if (registeredClass.baseClass) {\n            if (registeredClass.baseClass.__derivedClasses === undefined) {\n              registeredClass.baseClass.__derivedClasses = [];\n            }\n            registeredClass.baseClass.__derivedClasses.push(registeredClass);\n          }\n          var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n          var pointerConverter = new RegisteredPointer(\n            name + '*',\n            registeredClass,\n            false,\n            false,\n            false\n          );\n          var constPointerConverter = new RegisteredPointer(\n            name + ' const*',\n            registeredClass,\n            false,\n            true,\n            false\n          );\n          registeredPointers[rawType] = {\n            pointerType: pointerConverter,\n            constPointerType: constPointerConverter\n          };\n          replacePublicSymbol(legalFunctionName, constructor);\n          return [referenceConverter, pointerConverter, constPointerConverter];\n        }\n      );\n    }\n    var heap32VectorToArray = (count, firstElement) => {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAPU32[((firstElement + i * 4) >>> 2) >>> 0]);\n      }\n      return array;\n    };\n    var runDestructors = destructors => {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    };\n    function newFunc(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\n          `new_ called with constructor type ${typeof constructor} which is not a function`\n        );\n      }\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function craftInvokerFunction(\n      humanName,\n      argTypes,\n      classType,\n      cppInvokerFunc,\n      cppTargetFunc,\n      isAsync\n    ) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\n          \"argTypes array size mismatch! Must at least get return value and 'this' types!\"\n        );\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== 'void';\n      var argsList = '';\n      var argsListWired = '';\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? ', ' : '') + 'arg' + i;\n        argsListWired += (i !== 0 ? ', ' : '') + 'arg' + i + 'Wired';\n      }\n      var invokerFnBody = `\\n        return function ${makeLegalFunctionName(\n        humanName\n      )}(${argsList}) {\\n        if (arguments.length !== ${\n        argCount - 2\n      }) {\\n          throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${\n        argCount - 2\n      }');\\n        }`;\n      if (needsDestructorStack) {\n        invokerFnBody += 'var destructors = [];\\n';\n      }\n      var dtorStack = needsDestructorStack ? 'destructors' : 'null';\n      var args1 = ['throwBindingError', 'invoker', 'fn', 'runDestructors', 'retType', 'classParam'];\n      var args2 = [\n        throwBindingError,\n        cppInvokerFunc,\n        cppTargetFunc,\n        runDestructors,\n        argTypes[0],\n        argTypes[1]\n      ];\n      if (isClassMethodFunc) {\n        invokerFnBody += 'var thisWired = classParam.toWireType(' + dtorStack + ', this);\\n';\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody +=\n          'var arg' +\n          i +\n          'Wired = argType' +\n          i +\n          '.toWireType(' +\n          dtorStack +\n          ', arg' +\n          i +\n          '); // ' +\n          argTypes[i + 2].name +\n          '\\n';\n        args1.push('argType' + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired = 'thisWired' + (argsListWired.length > 0 ? ', ' : '') + argsListWired;\n      }\n      invokerFnBody +=\n        (returns || isAsync ? 'var rv = ' : '') +\n        'invoker(fn' +\n        (argsListWired.length > 0 ? ', ' : '') +\n        argsListWired +\n        ');\\n';\n      if (needsDestructorStack) {\n        invokerFnBody += 'runDestructors(destructors);\\n';\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? 'thisWired' : 'arg' + (i - 2) + 'Wired';\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + '_dtor(' + paramName + '); // ' + argTypes[i].name + '\\n';\n            args1.push(paramName + '_dtor');\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody += 'var ret = retType.fromWireType(rv);\\n' + 'return ret;\\n';\n      } else {\n      }\n      invokerFnBody += '}\\n';\n      args1.push(invokerFnBody);\n      return newFunc(Function, args1).apply(null, args2);\n    }\n    function __embind_register_class_constructor(\n      rawClassType,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      invoker,\n      rawConstructor\n    ) {\n      rawClassType >>>= 0;\n      rawArgTypesAddr >>>= 0;\n      invokerSignature >>>= 0;\n      invoker >>>= 0;\n      rawConstructor >>>= 0;\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = `constructor ${classType.name}`;\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\n            `Cannot register multiple constructors with identical number of parameters (${\n              argCount - 1\n            }) for class '${\n              classType.name\n            }'! Overload resolution is currently only performed using the parameter count, not actual type info!`\n          );\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\n          throwUnboundTypeError(\n            `Cannot construct ${classType.name} due to unbound types`,\n            rawArgTypes\n          );\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, argTypes => {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(\n            humanName,\n            argTypes,\n            null,\n            invoker,\n            rawConstructor\n          );\n          return [];\n        });\n        return [];\n      });\n    }\n    function __embind_register_class_function(\n      rawClassType,\n      methodName,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      rawInvoker,\n      context,\n      isPureVirtual,\n      isAsync\n    ) {\n      rawClassType >>>= 0;\n      methodName >>>= 0;\n      rawArgTypesAddr >>>= 0;\n      invokerSignature >>>= 0;\n      rawInvoker >>>= 0;\n      context >>>= 0;\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = `${classType.name}.${methodName}`;\n        if (methodName.startsWith('@@')) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (\n          undefined === method ||\n          (undefined === method.overloadTable &&\n            method.className !== classType.name &&\n            method.argCount === argCount - 2)\n        ) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(\n            humanName,\n            argTypes,\n            classType,\n            rawInvoker,\n            context,\n            isAsync\n          );\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    }\n    function handleAllocatorInit() {\n      Object.assign(HandleAllocator.prototype, {\n        get(id) {\n          return this.allocated[id];\n        },\n        has(id) {\n          return this.allocated[id] !== undefined;\n        },\n        allocate(handle) {\n          var id = this.freelist.pop() || this.allocated.length;\n          this.allocated[id] = handle;\n          return id;\n        },\n        free(id) {\n          this.allocated[id] = undefined;\n          this.freelist.push(id);\n        }\n      });\n    }\n    function HandleAllocator() {\n      this.allocated = [undefined];\n      this.freelist = [];\n    }\n    var emval_handles = new HandleAllocator();\n    function __emval_decref(handle) {\n      handle >>>= 0;\n      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n        emval_handles.free(handle);\n      }\n    }\n    var count_emval_handles = () => {\n      var count = 0;\n      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\n        if (emval_handles.allocated[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    };\n    var init_emval = () => {\n      emval_handles.allocated.push(\n        {value: undefined},\n        {value: null},\n        {value: true},\n        {value: false}\n      );\n      emval_handles.reserved = emval_handles.allocated.length;\n      Module['count_emval_handles'] = count_emval_handles;\n    };\n    var Emval = {\n      toValue: handle => {\n        if (!handle) {\n          throwBindingError('Cannot use deleted val. handle = ' + handle);\n        }\n        return emval_handles.get(handle).value;\n      },\n      toHandle: value => {\n        switch (value) {\n          case undefined:\n            return 1;\n          case null:\n            return 2;\n          case true:\n            return 3;\n          case false:\n            return 4;\n          default: {\n            return emval_handles.allocate({refcount: 1, value: value});\n          }\n        }\n      }\n    };\n    function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAP32[(pointer >>> 2) >>> 0]);\n    }\n    var __embind_register_emval = function (rawType, name) {\n      rawType >>>= 0;\n      name >>>= 0;\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: handle => {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        toWireType: (destructors, value) => Emval.toHandle(value),\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    };\n    var enumReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP8[(pointer >>> 0) >>> 0]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU8[(pointer >>> 0) >>> 0]);\n              };\n        case 2:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP16[(pointer >>> 1) >>> 0]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU16[(pointer >>> 1) >>> 0]);\n              };\n        case 4:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP32[(pointer >>> 2) >>> 0]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU32[(pointer >>> 2) >>> 0]);\n              };\n        default:\n          throw new TypeError(`invalid integer width (${width}): ${name}`);\n      }\n    };\n    function __embind_register_enum(rawType, name, size, isSigned) {\n      rawType >>>= 0;\n      name >>>= 0;\n      size >>>= 0;\n      name = readLatin1String(name);\n      function ctor() {}\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        fromWireType: function (c) {\n          return this.constructor.values[c];\n        },\n        toWireType: (destructors, c) => c.value,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: enumReadValueFromPointer(name, size, isSigned),\n        destructorFunction: null\n      });\n      exposePublicSymbol(name, ctor);\n    }\n    var requireRegisteredType = (rawType, humanName) => {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(humanName + ' has unknown type ' + getTypeName(rawType));\n      }\n      return impl;\n    };\n    function __embind_register_enum_value(rawEnumType, name, enumValue) {\n      rawEnumType >>>= 0;\n      name >>>= 0;\n      enumValue >>>= 0;\n      var enumType = requireRegisteredType(rawEnumType, 'enum');\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {value: enumValue},\n        constructor: {value: createNamedFunction(`${enumType.name}_${name}`, function () {})}\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    }\n    var embindRepr = v => {\n      if (v === null) {\n        return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n        return v.toString();\n      } else {\n        return '' + v;\n      }\n    };\n    var floatReadValueFromPointer = (name, width) => {\n      switch (width) {\n        case 4:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF32[(pointer >>> 2) >>> 0]);\n          };\n        case 8:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF64[(pointer >>> 3) >>> 0]);\n          };\n        default:\n          throw new TypeError(`invalid float width (${width}): ${name}`);\n      }\n    };\n    var __embind_register_float = function (rawType, name, size) {\n      rawType >>>= 0;\n      name >>>= 0;\n      size >>>= 0;\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: value => value,\n        toWireType: (destructors, value) => value,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: floatReadValueFromPointer(name, size),\n        destructorFunction: null\n      });\n    };\n    function __embind_register_function(\n      name,\n      argCount,\n      rawArgTypesAddr,\n      signature,\n      rawInvoker,\n      fn,\n      isAsync\n    ) {\n      name >>>= 0;\n      rawArgTypesAddr >>>= 0;\n      signature >>>= 0;\n      rawInvoker >>>= 0;\n      fn >>>= 0;\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(\n        name,\n        function () {\n          throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\n        },\n        argCount - 1\n      );\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(\n          name,\n          craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync),\n          argCount - 1\n        );\n        return [];\n      });\n    }\n    var integerReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed\n            ? pointer => HEAP8[(pointer >>> 0) >>> 0]\n            : pointer => HEAPU8[(pointer >>> 0) >>> 0];\n        case 2:\n          return signed\n            ? pointer => HEAP16[(pointer >>> 1) >>> 0]\n            : pointer => HEAPU16[(pointer >>> 1) >>> 0];\n        case 4:\n          return signed\n            ? pointer => HEAP32[(pointer >>> 2) >>> 0]\n            : pointer => HEAPU32[(pointer >>> 2) >>> 0];\n        default:\n          throw new TypeError(`invalid integer width (${width}): ${name}`);\n      }\n    };\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      primitiveType >>>= 0;\n      name >>>= 0;\n      size >>>= 0;\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var fromWireType = value => value;\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = value => (value << bitshift) >>> bitshift;\n      }\n      var isUnsignedType = name.includes('unsigned');\n      var checkAssertions = (value, toTypeName) => {};\n      var toWireType;\n      if (isUnsignedType) {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value >>> 0;\n        };\n      } else {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value;\n        };\n      }\n      registerType(primitiveType, {\n        name: name,\n        fromWireType: fromWireType,\n        toWireType: toWireType,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      rawType >>>= 0;\n      name >>>= 0;\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array\n      ];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        var size = HEAPU32[(handle >>> 2) >>> 0];\n        var data = HEAPU32[((handle + 4) >>> 2) >>> 0];\n        return new TA(HEAP8.buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(\n        rawType,\n        {\n          name: name,\n          fromWireType: decodeMemoryView,\n          argPackAdvance: GenericWireTypeSize,\n          readValueFromPointer: decodeMemoryView\n        },\n        {ignoreDuplicateRegistrations: true}\n      );\n    }\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      outIdx >>>= 0;\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++ >>> 0] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++ >>> 0] = 192 | (u >> 6);\n          heap[outIdx++ >>> 0] = 128 | (u & 63);\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++ >>> 0] = 224 | (u >> 12);\n          heap[outIdx++ >>> 0] = 128 | ((u >> 6) & 63);\n          heap[outIdx++ >>> 0] = 128 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++ >>> 0] = 240 | (u >> 18);\n          heap[outIdx++ >>> 0] = 128 | ((u >> 12) & 63);\n          heap[outIdx++ >>> 0] = 128 | ((u >> 6) & 63);\n          heap[outIdx++ >>> 0] = 128 | (u & 63);\n        }\n      }\n      heap[outIdx >>> 0] = 0;\n      return outIdx - startIdx;\n    };\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) =>\n      stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    var lengthBytesUTF8 = str => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n    var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      idx >>>= 0;\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        }\n      }\n      return str;\n    };\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      ptr >>>= 0;\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n    var __embind_register_std_string = function (rawType, name) {\n      rawType >>>= 0;\n      name >>>= 0;\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === 'std::string';\n      registerType(rawType, {\n        name: name,\n        fromWireType: value => {\n          var length = HEAPU32[(value >>> 2) >>> 0];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[(payload + i) >>> 0]);\n            }\n            str = a.join('');\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: (destructors, value) => {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == 'string';\n          if (\n            !(\n              valueIsOfTypeString ||\n              value instanceof Uint8Array ||\n              value instanceof Uint8ClampedArray ||\n              value instanceof Int8Array\n            )\n          ) {\n            throwBindingError('Cannot pass non-string to std::string');\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[(base >>> 2) >>> 0] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                }\n                HEAPU8[(ptr + i) >>> 0] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[(ptr + i) >>> 0] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: readPointer,\n        destructorFunction: ptr => _free(ptr)\n      });\n    };\n    var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx >>> 0]) ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));\n      var str = '';\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[((ptr + i * 2) >>> 1) >>> 0];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    };\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[(outPtr >>> 1) >>> 0] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[(outPtr >>> 1) >>> 0] = 0;\n      return outPtr - startPtr;\n    };\n    var lengthBytesUTF16 = str => str.length * 2;\n    var UTF32ToString = (ptr, maxBytesToRead) => {\n      var i = 0;\n      var str = '';\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[((ptr + i * 4) >>> 2) >>> 0];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    };\n    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n      outPtr >>>= 0;\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\n        }\n        HEAP32[(outPtr >>> 2) >>> 0] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[(outPtr >>> 2) >>> 0] = 0;\n      return outPtr - startPtr;\n    };\n    var lengthBytesUTF32 = str => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    };\n    var __embind_register_std_wstring = function (rawType, charSize, name) {\n      rawType >>>= 0;\n      charSize >>>= 0;\n      name >>>= 0;\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = () => HEAPU16;\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = () => HEAPU32;\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        fromWireType: value => {\n          var length = HEAPU32[(value >>> 2) >>> 0];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >>> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: (destructors, value) => {\n          if (!(typeof value == 'string')) {\n            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >>> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: ptr => _free(ptr)\n      });\n    };\n    var __embind_register_void = function (rawType, name) {\n      rawType >>>= 0;\n      name >>>= 0;\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        argPackAdvance: 0,\n        fromWireType: () => undefined,\n        toWireType: (destructors, o) => undefined\n      });\n    };\n    function __emval_incref(handle) {\n      handle >>>= 0;\n      if (handle > 4) {\n        emval_handles.get(handle).refcount += 1;\n      }\n    }\n    function __emval_take_value(type, arg) {\n      type >>>= 0;\n      arg >>>= 0;\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](arg);\n      return Emval.toHandle(v);\n    }\n    var _abort = () => {\n      abort('');\n    };\n    function _emscripten_memcpy_big(dest, src, num) {\n      dest >>>= 0;\n      src >>>= 0;\n      num >>>= 0;\n      return HEAPU8.copyWithin(dest >>> 0, src >>> 0, (src + num) >>> 0);\n    }\n    var getHeapMax = () => 3221225472;\n    var growMemory = size => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {}\n    };\n    function _emscripten_resize_heap(requestedSize) {\n      requestedSize >>>= 0;\n      var oldSize = HEAPU8.length;\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      var alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(\n          maxHeapSize,\n          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\n        );\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    }\n    embind_init_charCodes();\n    BindingError = Module['BindingError'] = class BindingError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = 'BindingError';\n      }\n    };\n    InternalError = Module['InternalError'] = class InternalError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = 'InternalError';\n      }\n    };\n    init_ClassHandle();\n    init_embind();\n    init_RegisteredPointer();\n    UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');\n    handleAllocatorInit();\n    init_emval();\n    var wasmImports = {\n      w: ___cxa_rethrow,\n      b: ___cxa_throw,\n      o: __embind_register_bigint,\n      t: __embind_register_bool,\n      d: __embind_register_class,\n      e: __embind_register_class_constructor,\n      a: __embind_register_class_function,\n      s: __embind_register_emval,\n      q: __embind_register_enum,\n      i: __embind_register_enum_value,\n      m: __embind_register_float,\n      g: __embind_register_function,\n      f: __embind_register_integer,\n      c: __embind_register_memory_view,\n      l: __embind_register_std_string,\n      j: __embind_register_std_wstring,\n      u: __embind_register_void,\n      v: __emval_decref,\n      n: __emval_incref,\n      h: __emval_take_value,\n      k: _abort,\n      r: _emscripten_memcpy_big,\n      p: _emscripten_resize_heap\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['y'])();\n    var ___getTypeName = a0 => (___getTypeName = wasmExports['A'])(a0);\n    var __embind_initialize_bindings = (Module['__embind_initialize_bindings'] = () =>\n      (__embind_initialize_bindings = Module['__embind_initialize_bindings'] = wasmExports['B'])());\n    var ___errno_location = () => (___errno_location = wasmExports['__errno_location'])();\n    var _malloc = a0 => (_malloc = wasmExports['C'])(a0);\n    var _free = a0 => (_free = wasmExports['D'])(a0);\n    var ___cxa_is_pointer_type = a0 => (___cxa_is_pointer_type = wasmExports['E'])(a0);\n    function applySignatureConversions(wasmExports) {\n      wasmExports = Object.assign({}, wasmExports);\n      var makeWrapper_pp = f => a0 => f(a0) >>> 0;\n      var makeWrapper_p = f => () => f() >>> 0;\n      wasmExports['A'] = makeWrapper_pp(wasmExports['A']);\n      wasmExports['__errno_location'] = makeWrapper_p(wasmExports['__errno_location']);\n      wasmExports['C'] = makeWrapper_pp(wasmExports['C']);\n      wasmExports['stackSave'] = makeWrapper_p(wasmExports['stackSave']);\n      wasmExports['stackAlloc'] = makeWrapper_pp(wasmExports['stackAlloc']);\n      return wasmExports;\n    }\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        postRun();\n      }\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n    run();\n\n    return moduleArg.ready;\n  };\n})();\nif (typeof exports === 'object' && typeof module === 'object') module.exports = geoda;\nelse if (typeof define === 'function' && define['amd']) define([], () => geoda);\n", "\n\nimport type {CustomEmbindModule} from '../wasm';\n// @ts-expect-error - TS doesn't seem to like .cjs working alongside .d.ts\nimport geodaAny from '../wasm/index.cjs';\n\nconst geoda: () => Promise<CustomEmbindModule> = geodaAny;\n\n// Singlton wasmInstance promise\nlet wasmInstancePromise: Promise<CustomEmbindModule> | null = null;\n\n// Initialize geoda WASM instance\n// You can use the promise directly, so it's compatible with functions that\n// accept argument `wasm: CustomEmbindModule`. Or, use it to initialize a\n// global wasm instance for synchronous function call,\n// e.g.: initGeoDa().then(wasm => setGeoDa(wasm))\nexport async function initWASM(): Promise<CustomEmbindModule> {\n  if (wasmInstancePromise === null) {\n    wasmInstancePromise = geoda();\n  }\n  return wasmInstancePromise;\n}\n\n// Reset WASM instance after it throws runtime error e.g. OOM\nexport function resetWASM(): void {\n  wasmInstancePromise = null;\n  wasmInstance = null;\n  // in case of sync call, try to re-initialize GeoDa immediately\n  geoda().then(instance => {\n    wasmInstance = instance;\n  });\n}\n\n// Global nonPromise instance of GeoDa WASM module\nlet wasmInstance: CustomEmbindModule | null = null;\n\n// User can use initWASM() to get a promise of GeoDa instance\n// They can use the promise directly, or they can call `setWASM()`\n// to keep the nonPromise geoda instance in this library globally.\nexport function setWASM(instance: CustomEmbindModule): void {\n  wasmInstance = instance;\n}\n\n// return the global instance of GeoDa WASM module\n// This should be called with cautious since it works depending on above\n// functions to initialize the wasm instance succesfully.\n// The result could be \"null\" which indicates geoda wasm instance has\n// not been initialized successfully.\nexport function getWASM(): CustomEmbindModule | null {\n  return wasmInstance;\n}\n", "\n\nimport {Feature, Geometry, Position} from 'geojson';\n\nimport {\n  CustomEmbindModule,\n  PolygonCollection,\n  PointCollection,\n  LineCollection,\n  Polygon as GeoDaPolygon\n} from '../../wasm';\n\nexport type GeometryInput = {\n  features: Feature<Geometry>[] | null;\n  latitudes?: Float64Array | null;\n  longitudes?: Float64Array | null;\n  index?: number[] | null;\n};\n\nexport type GeometryCollectionType = PointCollection | LineCollection | PolygonCollection | null;\n\n// Convert from GeoJSON features (MultiPolygon and Polygon) to geoda.PolygonCollection\nexport function getPolygonCollection(\n  features: Feature[],\n  wasm: CustomEmbindModule,\n  fixPolygon?: boolean,\n  convertToUTM?: boolean\n): PolygonCollection {\n  let ptIndex = 0;\n  // for WASM data structure, please see: src/spatial_features.h in geoda repo\n  const xs = new wasm.VectorDouble();\n  const ys = new wasm.VectorDouble();\n  const parts = new wasm.VectorUInt();\n  const holes = new wasm.VectorUInt();\n  const sizes = new wasm.VectorUInt();\n\n  function handlePolygonRing(polygon: Position[][], numParts: number): number {\n    // each ring (even an empty ring) starts at ptIndex\n    parts.push_back(ptIndex);\n    // the first ring (exterior) is not a hole\n    holes.push_back(0);\n\n    for (let j = 0, m = polygon.length; j < m; ++j) {\n      const ring = polygon[j];\n      if (j > 0) {\n        parts.push_back(ptIndex);\n        holes.push_back(1);\n      }\n      if (ring.length > 0) numParts += 1;\n      for (let k = 0, npts = ring.length; k < npts; ++k) {\n        const pt = ring[k];\n        xs.push_back(pt[0]);\n        ys.push_back(pt[1]);\n        ptIndex += 1;\n      }\n    }\n\n    return numParts;\n  }\n\n  for (let i = 0, n = features.length; i < n; ++i) {\n    const feat = features[i];\n    let numParts = 0;\n    if (feat.geometry.type === 'MultiPolygon') {\n      for (let j = 0, m = feat.geometry.coordinates.length; j < m; ++j) {\n        const poly = feat.geometry.coordinates[j];\n        numParts = handlePolygonRing(poly, numParts);\n      }\n    } else if (feat.geometry.type === 'Polygon') {\n      numParts = handlePolygonRing(feat.geometry.coordinates, numParts);\n    }\n    sizes.push_back(numParts);\n  }\n  const pc = new wasm.PolygonCollection(\n    xs,\n    ys,\n    parts,\n    holes,\n    sizes,\n    fixPolygon ?? false,\n    convertToUTM ?? false\n  );\n  return pc;\n}\n\n// Convert from GeoJSON features (MultiLineString and LineString) to geoda.LineCollection\nexport function getLineCollection(\n  features: Feature[],\n  wasm: CustomEmbindModule,\n  convertToUTM?: boolean\n): LineCollection {\n  let ptIndex = 0;\n  // for WASM data structure, please see: src/spatial_features.h in geoda repo\n  const xs = new wasm.VectorDouble();\n  const ys = new wasm.VectorDouble();\n  const parts = new wasm.VectorUInt();\n  const sizes = new wasm.VectorUInt();\n\n  function handleLineSegment(lineSeg: Position[]): boolean {\n    parts.push_back(ptIndex);\n    let validLine = false;\n    for (let j = 0, m = lineSeg.length; j < m; ++j) {\n      const pt = lineSeg[j];\n      xs.push_back(pt[0]);\n      ys.push_back(pt[1]);\n      ptIndex += 1;\n      validLine = true;\n    }\n    return validLine;\n  }\n\n  for (let i = 0, n = features.length; i < n; ++i) {\n    const feat = features[i];\n    let numParts = 0;\n    if (feat.geometry.type === 'MultiLineString') {\n      for (let j = 0, m = feat.geometry.coordinates.length; j < m; ++j) {\n        // eslint-disable-next-line max-depth\n        if (handleLineSegment(feat.geometry.coordinates[j])) {\n          numParts += 1;\n        }\n      }\n    } else if (feat.geometry.type === 'LineString') {\n      if (handleLineSegment(feat.geometry.coordinates)) {\n        numParts += 1;\n      }\n    }\n    sizes.push_back(numParts);\n  }\n  const lc = new wasm.LineCollection(xs, ys, parts, sizes, convertToUTM ?? false);\n  return lc;\n}\n\n// Convert from GeoJSON features (MultiPoint and Point) to geoda.PointCollection\nexport function getPointCollection(\n  features: Feature[],\n  wasm: CustomEmbindModule,\n  convertToUTM?: boolean\n): PointCollection {\n  let ptIndex = 0;\n  // for WASM data structure, please see: src/spatial_features.h in geoda repo\n  const xs = new wasm.VectorDouble();\n  const ys = new wasm.VectorDouble();\n  const parts = new wasm.VectorUInt();\n  const sizes = new wasm.VectorUInt();\n\n  function handlePoint(point: Position): boolean {\n    let isValid = false;\n    if (point.length >= 2) {\n      xs.push_back(point[0]);\n      ys.push_back(point[1]);\n      isValid = true;\n    }\n    ptIndex += 1;\n    return isValid;\n  }\n\n  for (let i = 0, n = features.length; i < n; ++i) {\n    const feat = features[i];\n    let numParts = 0;\n    if (feat.geometry.type === 'MultiPoint') {\n      parts.push_back(ptIndex);\n      for (let j = 0, m = feat.geometry.coordinates.length; j < m; ++j) {\n        // eslint-disable-next-line max-depth\n        if (handlePoint(feat.geometry.coordinates[j])) {\n          numParts += 1;\n        }\n      }\n    } else if (feat.geometry.type === 'Point') {\n      parts.push_back(ptIndex);\n      if (handlePoint(feat.geometry.coordinates)) {\n        numParts += 1;\n      }\n    }\n    sizes.push_back(numParts);\n  }\n  const pc = new wasm.PointCollection(xs, ys, parts, sizes, convertToUTM ?? false);\n  return pc;\n}\n\n/**\n * Convert from lat/lng pairs to geoda.PointCollection\n * start/end are only for parallel spatial join that each webworker use\n * a subset of lat/lng data in spatial join\n */\nexport function getPointCollectionFromLatLng(\n  lat: number[] | Float64Array,\n  lng: number[] | Float64Array,\n  wasm: CustomEmbindModule,\n  start?: number,\n  end?: number\n): PointCollection {\n  let ptIndex = 0;\n  // for WASM data structure, please see: src/spatial_features.h in geoda repo\n  const xs = new wasm.VectorDouble();\n  const ys = new wasm.VectorDouble();\n  const parts = new wasm.VectorUInt();\n  const sizes = new wasm.VectorUInt();\n\n  for (let i = start ?? 0, n = end ?? lat.length; i < n; ++i) {\n    sizes.push_back(1);\n    parts.push_back(ptIndex);\n    xs.push_back(lng[i]);\n    ys.push_back(lat[i]);\n    ptIndex += 1;\n  }\n\n  const convertToUTM = false;\n  const pc = new wasm.PointCollection(xs, ys, parts, sizes, convertToUTM);\n  return pc;\n}\n\n/**\n * Get GeometryCollection from SpatialJoinInput\n * start/end are only for parallel spatial join that each webworker use\n * a subset of lat/lng data in spatial join\n */\nexport function getGeometryCollection(\n  input: GeometryInput,\n  wasm: CustomEmbindModule,\n  start?: number,\n  end?: number\n): GeometryCollectionType {\n  if (input.features && input.features.length > 0) {\n    // create GeometryCollection from GeoJSON\n    const geomType = input.features[0].geometry.type;\n\n    if (geomType === 'Polygon' || geomType === 'MultiPolygon') {\n      return getPolygonCollection(input.features, wasm);\n    } else if (geomType === 'LineString' || geomType === 'MultiLineString') {\n      return getLineCollection(input.features, wasm);\n    } else if (geomType === 'Point' || geomType === 'MultiPoint') {\n      return getPointCollection(input.features, wasm);\n    }\n  } else if (input.latitudes && input.longitudes) {\n    // create PointCollection from lat/lng\n    return getPointCollectionFromLatLng(input.latitudes, input.longitudes, wasm, start, end);\n  }\n  return null;\n}\n\n// eslint-disable-next-line max-statements\nexport function getGeojsonPolygon(poly: GeoDaPolygon): Feature {\n  // for data structure of GeoDaPolygon, please see src/spatial_features.h in geoda repo\n  const xs = poly.getX();\n  const ys = poly.getY();\n  const parts = poly.getParts();\n  const holes = poly.getHoles();\n\n  const numPoints = xs.size();\n  const numParts = parts.size();\n\n  let numExtRings = 0;\n  for (let i = 0; i < numParts; ++i) {\n    if (holes.get(i) === 0) numExtRings += 1;\n  }\n\n  const isMultiPolygon = numExtRings > 1;\n\n  if (isMultiPolygon) {\n    // [[extRing, hole, hole], [extRing, hole]]\n    const multiPoly = Array(numExtRings);\n    let polyIndex = -1;\n    for (let i = 0; i < numParts; ++i) {\n      if (holes.get(i) === 0) {\n        // extRing\n        polyIndex += 1;\n        multiPoly[polyIndex] = [];\n      }\n      const ring: number[][] = [];\n      const start = parts.get(i);\n      const end = i === numParts - 1 ? numPoints : parts.get(i + 1);\n      for (let j = start; j < end; ++j) {\n        ring.push([xs.get(j), ys.get(j)]);\n      }\n      multiPoly[polyIndex].push(ring);\n    }\n    return {\n      type: 'Feature',\n      geometry: {\n        type: 'MultiPolygon',\n        coordinates: multiPoly\n      },\n      properties: {}\n    };\n  } else {\n    // [extRing, hole, hole]\n    const coordinates = Array(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      const ring: number[][] = [];\n      const start = parts.get(i);\n      const end = i === numParts - 1 ? numPoints : parts.get(i + 1);\n      for (let j = start; j < end; ++j) {\n        ring.push([xs.get(j), ys.get(j)]);\n      }\n      coordinates[i] = ring;\n    }\n    return {\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates\n      },\n      properties: {}\n    };\n  }\n}\n", "\n\nimport {Feature, MultiPolygon, Polygon, Point} from 'geojson';\n\nimport {getPolygonCollection, getLineCollection, getPointCollection} from '../features/geometry';\nimport {initWASM, getWASM} from '../init';\n\n// Get centroids from a collection of GeoJson Polygons/MultiPolygons\nexport async function getCentroids(\n  polygons: Feature<Polygon | MultiPolygon>[]\n): Promise<Array<Feature<Point> | null>> {\n  const wasm = await initWASM();\n\n  const geodaPolys = getPolygonCollection(polygons, wasm);\n  const coords = wasm.getCentroids(geodaPolys);\n  const numPoints = coords.size();\n  const centroids: Array<Feature<Point> | null> = [];\n  for (let i = 0; i < numPoints; ++i) {\n    if (coords.get(i).size() === 0) {\n      centroids.push(null);\n    } else {\n      centroids.push({\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: [coords.get(i).get(0), coords.get(i).get(1)]\n        },\n        properties: {}\n      });\n    }\n  }\n  geodaPolys.delete();\n  return centroids;\n}\n\n// Get centroid for one feature. This function is used by column metric: centroid()\nexport function getCentroid(feature: Feature | null): Array<number> | null {\n  const wasm = getWASM();\n  if (!wasm || !feature) return null;\n\n  const geomType = feature?.geometry?.type;\n\n  let geom;\n  if (geomType === 'Polygon' || geomType === 'MultiPolygon') {\n    geom = getPolygonCollection([feature], wasm);\n  } else if (geomType === 'LineString' || geomType === 'MultiLineString') {\n    geom = getLineCollection([feature], wasm);\n  } else if (geomType === 'Point' || geomType === 'MultiPoint') {\n    geom = getPointCollection([feature], wasm);\n  } else {\n    return null;\n  }\n  const coords = wasm.getCentroids(geom);\n  geom.delete();\n\n  return coords.size() > 0 && coords.get(0).size() === 2\n    ? [coords.get(0).get(0), coords.get(0).get(1)]\n    : null;\n}\n\n// Get centroids from an array of Geojson Feature. This function is used by geojson-layer to\n// get centroids (memorized) for filtering and labeling\n// eslint-disable-next-line complexity\nexport function getGeojsonCentroids(features: Array<Feature | null>): Array<Array<number> | null> {\n  let result: Array<Array<number> | null> = [];\n  const wasm = getWASM();\n  if (!wasm) return result;\n\n  const nFeatures = features.length;\n  const validIndex: number[] = [];\n  const validFeatures: Feature[] = [];\n\n  result = Array<Array<number> | null>(nFeatures).fill(null);\n\n  let geomType: string | null = null;\n  for (let i = 0; i < nFeatures; ++i) {\n    const feat = features[i];\n    const featureGeomType = feat?.geometry?.type;\n    if (featureGeomType) {\n      if (!geomType) geomType = featureGeomType;\n      // geomType could be 'Polygon' and featureGeomType could be either 'Polygon' or 'MultiPolygon'\n      if (geomType.indexOf(featureGeomType) >= 0 || featureGeomType.indexOf(geomType) >= 0) {\n        validIndex.push(i);\n        validFeatures.push(feat);\n      }\n    }\n  }\n\n  const geom =\n    geomType === 'Polygon' || geomType === 'MultiPolygon'\n      ? getPolygonCollection(validFeatures, wasm)\n      : geomType === 'LineString' || geomType === 'MultiLineString'\n      ? getLineCollection(validFeatures, wasm)\n      : geomType === 'Point' || geomType === 'MultiPoint'\n      ? getPointCollection(validFeatures, wasm)\n      : null;\n\n  if (!geom) return result;\n\n  const centroids = wasm.getCentroids(geom);\n  geom.delete();\n\n  // point as input search [lng, lat]\n  for (let i = 0, n = centroids.size(); i < n; ++i) {\n    if (centroids.get(i).size() === 0) {\n      result[validIndex[i]] = null;\n    } else {\n      result[validIndex[i]] = [centroids.get(i)?.get(0), centroids.get(i)?.get(1)];\n    }\n  }\n\n  return result;\n}\n", "\n\nimport {Feature} from 'geojson';\n\nimport {getGeometryCollection} from '../features/geometry';\nimport {initWASM} from '../init';\n\n// for lat and lng, we use the great circle distance or arc distance\n// in the unit of mile or kilometer (KM)\nexport enum DistanceUnit {\n  Mile = 'Mile',\n  KM = 'KM'\n}\n\n/**\n * geometries: the geometries used to compute distance. NOTE: for Polygon type, the\n *  centroids are used to compute the distance\n * latLngArrays: the latitude and longitude array represents the input point geometries\n */\nexport type DistanceWeightsGeometryInput = {\n  geometries?: Feature[];\n  latLngArrays?: {\n    longitudes: Float64Array;\n    latitudes: Float64Array;\n  };\n};\n\n/**\n * distanceThreshold: the distance value that defines neighbors within this threshold\n * isMile: if the measurement unit of distance is mile (true), or kilometer (false)\n */\nexport type DistanceWeightsInput = DistanceWeightsGeometryInput & {\n  distanceThreshold: number;\n  distanceUnit: DistanceUnit;\n};\n\nexport type DistanceThresholdsInput = DistanceWeightsGeometryInput & {\n  distanceUnit: DistanceUnit;\n};\n\n/**\n * minDistanceThreshold: the minimum 1nn distance\n * suggestedDistanceThreshold: the maximum 1nn distance\n * maxDistanceThreshold: the approximate maximum pair distance\n * The 1st and 3rd values are used to define the range of distance thresholds\n * The 2nd value is used as suggested distance threshold, which guarantees at least one neighbor\n */\nexport type DistanceThresholdsOutput = {\n  minDistanceThreshold: number;\n  suggestedDistanceThreshold: number;\n  maxDistanceThreshold: number;\n};\n\nexport async function getDistanceThresholds({\n  distanceUnit,\n  geometries,\n  latLngArrays\n}: DistanceThresholdsInput): Promise<DistanceThresholdsOutput> {\n  const n = geometries?.length ?? latLngArrays?.latitudes.length ?? 0;\n\n  let minDistanceThreshold = 0;\n  let suggestedDistanceThreshold = 0;\n  let maxDistanceThreshold = 0;\n\n  if (n === 0) {\n    return {minDistanceThreshold, suggestedDistanceThreshold, maxDistanceThreshold};\n  }\n\n  const wasmInstance = await initWASM();\n  const geomCollection = getGeometryCollection(\n    {\n      features: geometries ?? null,\n      latitudes: latLngArrays?.latitudes ?? null,\n      longitudes: latLngArrays?.longitudes ?? null\n    },\n    wasmInstance\n  );\n\n  if (geomCollection) {\n    const result = wasmInstance.getDistanceThresholds(\n      geomCollection,\n      distanceUnit === DistanceUnit.Mile\n    );\n    minDistanceThreshold = result.get(0);\n    suggestedDistanceThreshold = result.get(1);\n    maxDistanceThreshold = result.get(2);\n  }\n\n  return {minDistanceThreshold, suggestedDistanceThreshold, maxDistanceThreshold};\n}\n\nexport async function getDistanceBasedNeighbors({\n  distanceThreshold,\n  distanceUnit,\n  geometries,\n  latLngArrays\n}: DistanceWeightsInput): Promise<number[][]> {\n  const n = geometries?.length ?? latLngArrays?.latitudes.length ?? 0;\n  const neighbors: number[][] = Array(n);\n\n  if (n === 0) {\n    return neighbors;\n  }\n\n  const wasmInstance = await initWASM();\n  const geomCollection = getGeometryCollection(\n    {\n      features: geometries ?? null,\n      latitudes: latLngArrays?.latitudes ?? null,\n      longitudes: latLngArrays?.longitudes ?? null\n    },\n    wasmInstance\n  );\n\n  if (geomCollection) {\n    const result = wasmInstance.getDistanceWeights(\n      geomCollection,\n      distanceThreshold,\n      distanceUnit === DistanceUnit.Mile\n    );\n    for (let i = 0; i < n; ++i) {\n      const nbrs = result.get(i);\n      const nbrIndices: number[] = Array(nbrs.size());\n      for (let j = 0, nbrSize = nbrs.size(); j < nbrSize; ++j) {\n        nbrIndices[j] = nbrs.get(j);\n      }\n      neighbors[i] = nbrIndices;\n    }\n  }\n\n  return neighbors;\n}\n", "\n\nimport {DistanceUnit} from './weights/distance-based-neighbors';\n\nexport const earthRadius = 6371008.8;\nconst mileToMeters = 1609.344;\n\nexport function lengthToDegrees(distance: number, unit: DistanceUnit): number {\n  // length to radians\n  const factor = unit === DistanceUnit.KM ? earthRadius / 1000 : earthRadius / mileToMeters;\n  const radians = distance / factor;\n  // radians to degrees\n  const degrees = radians % (2 * Math.PI);\n  return degrees;\n}\n\nexport function lengthToMeters(distance: number, unit: DistanceUnit): number {\n  return unit === DistanceUnit.Mile ? distance * mileToMeters : distance * 1000;\n}\n", "\n\nimport {Feature} from 'geojson';\n\nimport {CustomEmbindModule} from '../../wasm';\nimport {\n  getPolygonCollection,\n  getLineCollection,\n  getPointCollection,\n  getGeojsonPolygon\n} from '../features/geometry';\nimport {getWASM} from '../init';\nimport {lengthToMeters} from '../utils';\nimport {DistanceUnit} from '../weights/distance-based-neighbors';\n\n// eslint-disable-next-line complexity, max-statements\nexport function getBuffersSync(\n  features: Array<Feature | null>,\n  bufferDistance: number,\n  distanceUnit: DistanceUnit,\n  pointsPerCircle: number,\n  wasmInstance?: CustomEmbindModule\n): Array<Feature | null> {\n  const nFeatures = features.length;\n  const result: Array<Feature | null> = Array(nFeatures).fill(null);\n\n  // try to get geoda WASM instance from the library if no wasmInstance passed\n  const wasm = wasmInstance ?? getWASM();\n  if (!wasm) {\n    return result;\n  }\n\n  const validIndex: number[] = [];\n  const validFeatures: Feature[] = [];\n\n  let geomType: string | null = null;\n  for (let i = 0; i < nFeatures; ++i) {\n    const feat = features[i];\n    const featureGeomType = feat?.geometry?.type;\n    if (featureGeomType) {\n      if (!geomType) geomType = featureGeomType;\n      // geomType could be 'Polygon' and featureGeomType could be either 'Polygon' or 'MultiPolygon'\n      if (geomType.indexOf(featureGeomType) >= 0 || featureGeomType.indexOf(geomType) >= 0) {\n        validIndex.push(i);\n        validFeatures.push(feat);\n      }\n    }\n  }\n\n  const convertToUTM = true;\n  const fixPolygon = true;\n  const geom =\n    geomType === 'Polygon' || geomType === 'MultiPolygon'\n      ? getPolygonCollection(validFeatures, wasm, fixPolygon, convertToUTM)\n      : geomType === 'LineString' || geomType === 'MultiLineString'\n      ? getLineCollection(validFeatures, wasm, convertToUTM)\n      : geomType === 'Point' || geomType === 'MultiPoint'\n      ? getPointCollection(validFeatures, wasm, convertToUTM)\n      : null;\n\n  if (!geom) return result;\n\n  const dist = lengthToMeters(bufferDistance, distanceUnit);\n\n  for (let i = 0, n = validFeatures.length; i < n; ++i) {\n    const idx = validIndex[i];\n    const bufferPoly = geom.buffer(i, dist, pointsPerCircle);\n    const bufferGeojson = getGeojsonPolygon(bufferPoly);\n    result[idx] = bufferGeojson;\n  }\n  geom.delete();\n  return result;\n}\n\n// get Buffer for a single feature, used by metric function\nexport function getBufferSync(\n  feature: Feature,\n  bufferDistance: number,\n  distanceUnit: DistanceUnit,\n  pointsPerCircle: number,\n  wasmInstance?: CustomEmbindModule\n): Feature | null {\n  const bufferResults = getBuffersSync(\n    [feature],\n    bufferDistance,\n    distanceUnit,\n    pointsPerCircle,\n    wasmInstance\n  );\n  return bufferResults[0];\n}\n", "\n\nimport {CustomEmbindModule} from '../../wasm';\nimport {GeometryInput, getGeometryCollection} from '../features/geometry';\nimport {initWASM} from '../init';\n\nexport enum SpatialJoinType {\n  INTERSECTS = 'INTERSECTS',\n  WITHIN = 'WITHIN',\n  TOUCHES = 'TOUCHES',\n  OVERLAPS = 'OVERLAPS',\n  CROSSES = 'CROSSES',\n  EQUALS = 'EQUALS'\n}\n\n/**\n * The spatial join result is a 2d array, which represents the join relationship\n * between left and right table. For example: [[1,3], [0], [2, 4]] means\n * 0th left item joins with right items [1, 3]\n * 1st left item joins with right item [0]\n * 2nd left item joins with right items [2, 4]\n */\nexport type SpatialJoinResult = number[][];\n\nexport async function spatialJoin(\n  source: GeometryInput,\n  join: GeometryInput,\n  spatialJoinOperation: SpatialJoinType\n): Promise<SpatialJoinResult | null> {\n  const wasmInstance = await initWASM();\n\n  return runSpatialJoin(source, join, spatialJoinOperation, wasmInstance);\n}\n\n// eslint-disable-next-line max-params\nexport function runSpatialJoin(\n  source: GeometryInput,\n  join: GeometryInput,\n  spatialJoinOperation: SpatialJoinType,\n  wasmInstance: CustomEmbindModule,\n  start?: number,\n  end?: number\n): SpatialJoinResult | null {\n  const sourceGeometryCollection = getGeometryCollection(source, wasmInstance, start, end);\n  const joinGeometryCollection = getGeometryCollection(join, wasmInstance, start, end);\n  const spatialJoinOp = wasmInstance.SpatialJoinType[spatialJoinOperation];\n\n  if (sourceGeometryCollection && joinGeometryCollection && spatialJoinOp) {\n    const result = wasmInstance.spatialJoin(\n      sourceGeometryCollection,\n      joinGeometryCollection,\n      spatialJoinOp\n    );\n\n    // parse result\n    const joinRelation: SpatialJoinResult = [];\n    for (let i = 0, n = result.size(); i < n; ++i) {\n      const rightIndices = result.get(i);\n      const relation: number[] = [];\n      for (let j = 0, m = rightIndices.size(); j < m; ++j) {\n        relation.push(rightIndices.get(j));\n      }\n      joinRelation.push(relation);\n    }\n\n    return joinRelation;\n  }\n  return null;\n}\n", "\n\nimport {SpatialJoinResult, SpatialJoinType} from './join';\nimport {SpatialJoinWorkerInput} from './join-worker';\nimport {GeometryInput} from '../features/geometry';\n\ntype PreparedSpatialJoinData = {\n  taskDataArray: Array<SpatialJoinWorkerInput>;\n  indexTable: number[];\n  sourceSize: number;\n  joinSize: number;\n  divideRight: boolean;\n};\n\nexport function prepareParallelSpatialJoin(\n  source: GeometryInput,\n  join: GeometryInput,\n  spatialJoinOperation: SpatialJoinType,\n  workerCount: number\n): PreparedSpatialJoinData | null {\n  const taskDataArray: Array<SpatialJoinWorkerInput> = [];\n\n  // check the size of source and join\n  const sourceSize = source.features?.length ?? source.latitudes?.length;\n  const joinSize = join.features?.length ?? join.latitudes?.length;\n\n  if (!sourceSize || !joinSize) {\n    return null;\n  }\n\n  // for dividing the bigger dataset into several chunks if needed\n  // (e.g. no need for Float64Array)\n  const divideRight = sourceSize < joinSize;\n  const bigSize = divideRight ? joinSize : sourceSize;\n  const workChunk = Math.floor(bigSize / workerCount);\n  const remainder = bigSize % workerCount;\n\n  // index lookup table for dataset divided into chunks\n  const indexTable = new Array(workerCount);\n\n  const initSpatialJoinTasks = (taskIndex: number): SpatialJoinWorkerInput => {\n    // start is inclusive and end is exclusive\n    const start = taskIndex * workChunk;\n    let end = (taskIndex + 1) * workChunk;\n    if (taskIndex === workerCount - 1) {\n      // Allocate remainder rows to the last worker\n      end += remainder;\n    }\n    indexTable[taskIndex] = start;\n\n    return {\n      id: taskIndex,\n      source: prepareJoinDataset(source, divideRight, start, end),\n      join: prepareJoinDataset(join, !divideRight, start, end),\n      spatialJoinOperation,\n      start,\n      end\n    };\n  };\n\n  for (let i = 0; i < workerCount; ++i) {\n    const taskData = initSpatialJoinTasks(i);\n    taskDataArray.push(taskData);\n  }\n\n  return {taskDataArray, indexTable, sourceSize, joinSize, divideRight};\n}\n\nfunction prepareJoinDataset(\n  dataset: GeometryInput,\n  noSlicing: boolean,\n  start: number,\n  end: number\n): GeometryInput {\n  // latitudes/longitudes are Float64Array, so no need to slice and\n  // just zero-copy it to web workers, with [start, end] information.\n  // Currently, we will slice geojson features that are sent to each\n  // web worker -- slice and send is faster than sending whole to web\n  // workers. This wil be replaced with wkb (zero-copy) in the future.\n  return {\n    ...(dataset.latitudes ? {latitudes: dataset.latitudes} : {}),\n    ...(dataset.longitudes ? {longitudes: dataset.longitudes} : {}),\n    features:\n      dataset.features?.length && dataset.features.length > 0\n        ? noSlicing\n          ? dataset.features\n          : dataset.features?.slice(start, end)\n        : null\n  };\n}\n\n/**\n * process the join results from each web worker\n * the results should be filled into `joinRelation` (passed by reference)\n */\nexport function processJoinResultsFromWorker(\n  result: SpatialJoinResult,\n  divideRight: boolean,\n  indexTable: number[],\n  taskId: number,\n  joinRelation: number[][]\n): void {\n  for (let i = 0, n = result.length; i < n; ++i) {\n    const rightIndices = result[i];\n    for (let j = 0, m = rightIndices.length; j < m; ++j) {\n      if (divideRight) {\n        joinRelation[i].push(indexTable[taskId] + rightIndices[j]);\n      } else {\n        joinRelation[indexTable[taskId] + i].push(rightIndices[j]);\n      }\n    }\n  }\n}\n", "\n\nimport {SpatialJoinType, SpatialJoinResult} from './join';\nimport {SpatialJoinWorkerOutput} from './join-worker';\nimport {prepareParallelSpatialJoin, processJoinResultsFromWorker} from './parallel-join-utils';\nimport {GeometryInput} from '../features/geometry';\n\nconst DEFAULT_WORKER_COUNT = 6; // default number of parallel web workers\n\nexport type ParallelSpatialJoinOptions = {\n  workerUrl: string | URL;\n  workerCount?: number;\n};\n\ntype JoinResolve = (joinRelation: SpatialJoinResult) => void;\n\nexport async function parallelSpatialJoin(\n  source: GeometryInput,\n  join: GeometryInput,\n  spatialJoinOperation: SpatialJoinType,\n  options: ParallelSpatialJoinOptions\n): Promise<SpatialJoinResult | null> {\n  const workerCount = options?.workerCount ?? DEFAULT_WORKER_COUNT;\n\n  const preparedData = prepareParallelSpatialJoin(source, join, spatialJoinOperation, workerCount);\n  if (!preparedData) {\n    return null;\n  }\n\n  const {sourceSize, divideRight, indexTable, taskDataArray} = preparedData;\n\n  // final results\n  const joinRelation: SpatialJoinResult = [];\n  for (let i = 0; i < sourceSize; ++i) {\n    joinRelation.push([]);\n  }\n\n  // current running web workers\n  let runningWorkers = 0;\n\n  // resolve for join result\n  let joinResolve: JoinResolve;\n\n  const onTaskDone = (event: MessageEvent<SpatialJoinWorkerOutput>): void => {\n    // update number of running workers once it's done\n    runningWorkers--;\n    // get the results from the finished worker\n    const {result, id: taskId} = event.data;\n    processJoinResultsFromWorker(result, divideRight, indexTable, taskId, joinRelation);\n    // when all workers done\n    if (runningWorkers === 0) {\n      joinResolve(joinRelation);\n    }\n  };\n\n  const processSpatialJoinTasks = (resolve: JoinResolve): void => {\n    for (let i = 0; i < workerCount; ++i) {\n      const taskData = taskDataArray[i];\n      const instance = new Worker(new URL(options.workerUrl));\n      instance.onmessage = onTaskDone;\n      instance.postMessage(taskData);\n      runningWorkers++;\n    }\n    joinResolve = resolve;\n  };\n\n  return new Promise(processSpatialJoinTasks);\n}\n", "\n\nimport {Feature, Polygon, MultiPolygon} from 'geojson';\n\nimport {CustomEmbindModule} from '../../wasm';\nimport {getPolygonCollection, getGeojsonPolygon} from '../features/geometry';\nimport {initWASM, getWASM} from '../init';\n\nexport async function spatialMerge(polygons: Feature<Polygon | MultiPolygon>[]): Promise<Feature> {\n  const wasmInstance = await initWASM();\n\n  return spatialMergeSync(polygons, wasmInstance);\n}\n\nexport function spatialMergeSync(\n  polygons: Feature<Polygon | MultiPolygon>[],\n  wasmInstance?: CustomEmbindModule\n): Feature {\n  // try to get geoda WASM instance from the library if no wasmInstance passed\n  const wasm = wasmInstance ?? getWASM();\n  if (!wasm) {\n    // return empty Polygon feature to avoid crash\n    return {type: 'Feature', geometry: {type: 'Polygon', coordinates: []}, properties: {}};\n  }\n\n  // Boost.geometry/GEOS uses clockwise winding for exterior rings, which is\n  // different than Simple Feature implementation (geojson). We need to fix it.\n  const fixPolygon = true;\n\n  const polygonCollection = getPolygonCollection(polygons, wasm, fixPolygon);\n\n  // call geoda.spatialUnion()\n  const poly = wasm.spatialUnion(polygonCollection);\n\n  const unionResult = getGeojsonPolygon(poly);\n  return unionResult;\n}\n", "\n\nimport {Polygon, MultiPolygon, Point, Feature} from 'geojson';\n\nimport {\n  getPolygonCollection,\n  getPointCollection,\n  getPointCollectionFromLatLng\n} from '../features/geometry';\nimport {initWASM} from '../init';\n\nexport type SpatialCountPointInput = {\n  features: Feature<Point>[] | null;\n  latitudes: number[] | null;\n  longitudes: number[] | null;\n};\n\nexport async function spatialCount(\n  polygons: Feature<Polygon | MultiPolygon>[],\n  points: SpatialCountPointInput\n): Promise<number[]> {\n  const n = polygons.length;\n  const counts: number[] = Array(n);\n\n  if (n === 0) {\n    return counts;\n  }\n\n  const wasmInstance = await initWASM();\n  const polygonCollection = getPolygonCollection(polygons, wasmInstance);\n\n  let pointCollection;\n  if (points.features) {\n    pointCollection = getPointCollection(points.features, wasmInstance);\n  } else if (points.latitudes && points.longitudes) {\n    pointCollection = getPointCollectionFromLatLng(\n      points.latitudes,\n      points.longitudes,\n      wasmInstance\n    );\n  } else {\n    // something wrong with the input points\n    return counts;\n  }\n\n  const result = wasmInstance.spatialCount(polygonCollection, pointCollection);\n\n  for (let i = 0; i < n; ++i) {\n    counts[i] = result.get(i);\n  }\n\n  return counts;\n}\n", "\n\nimport {Feature} from 'geojson';\n\nimport {getGeometryCollection} from '../features/geometry';\nimport {initWASM} from '../init';\n\ntype NearestNeighborsInput = {\n  k: number;\n  geometries?: Feature[];\n  latLngArrays?: {\n    longitudes: Float64Array;\n    latitudes: Float64Array;\n  };\n};\n\nexport async function getNearestNeighbors({\n  k,\n  geometries,\n  latLngArrays\n}: NearestNeighborsInput): Promise<number[][]> {\n  const n = geometries ? geometries.length : latLngArrays ? latLngArrays.latitudes.length : 0;\n  const neighbors: number[][] = Array(n);\n\n  if (n === 0) {\n    return neighbors;\n  }\n\n  const wasmInstance = await initWASM();\n  const geomCollection = getGeometryCollection(\n    {\n      features: geometries ?? null,\n      latitudes: latLngArrays?.latitudes ?? null,\n      longitudes: latLngArrays?.longitudes ?? null\n    },\n    wasmInstance\n  );\n\n  if (geomCollection) {\n    const result = wasmInstance.getNearestNeighbors(geomCollection, k);\n    for (let i = 0; i < n; ++i) {\n      const nbrs = result.get(i);\n      const nbrIndices: number[] = Array(nbrs.size());\n      for (let j = 0, nbrSize = nbrs.size(); j < nbrSize; ++j) {\n        nbrIndices[j] = nbrs.get(j);\n      }\n      neighbors[i] = nbrIndices;\n    }\n  }\n\n  return neighbors;\n}\n", "\n\nimport {VectorDouble} from '../../wasm';\nimport {initWASM} from '../init';\n\nexport type LocalMoranResultType = {\n  isValid: boolean;\n  clusters: number[];\n  lagValues: number[];\n  pValues: number[];\n  lisaValues: number[];\n};\n\n// Get local moran statistics\nexport async function localMoran(\n  data: number[] | Float32Array,\n  neighbors: number[][],\n  permutation: number\n): Promise<LocalMoranResultType> {\n  const wasm = await initWASM();\n\n  const n = data.length;\n  const wasmData = new wasm.VectorDouble();\n  wasmData.resize(n, 0);\n  for (let i = 0; i < n; ++i) {\n    wasmData.set(i, data[i]);\n  }\n\n  const wasmNeighbors = new wasm.VecVecUInt();\n  for (let i = 0; i < n; ++i) {\n    const nbrs = neighbors[i];\n    const wasmNeighborIndices = new wasm.VectorUInt();\n    for (let j = 0, numNbrs = nbrs.length; j < numNbrs; ++j) {\n      wasmNeighborIndices.push_back(nbrs[j]);\n    }\n    wasmNeighbors.push_back(wasmNeighborIndices);\n  }\n\n  const result = wasm.localMoran(wasmData, wasmNeighbors, permutation);\n\n  return {\n    isValid: result.isValid(),\n    clusters: vecDoubleToNumber(result.getClusters()),\n    lagValues: vecDoubleToNumber(result.getLagValues()),\n    lisaValues: vecDoubleToNumber(result.getLisaValues()),\n    pValues: vecDoubleToNumber(result.getPValues())\n  };\n}\n\nexport function vecDoubleToNumber(data: VectorDouble): number[] {\n  const result: number[] = [];\n\n  const n = data.size();\n  for (let i = 0; i < n; ++i) {\n    result.push(data.get(i));\n  }\n\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["require_wasm", "__commonJSMin", "exports", "module", "geoda", "_scriptDir", "moduleArg", "Module", "readyPromiseResolve", "readyPromiseReject", "resolve", "reject", "moduleOverrides", "arguments_", "thisProgram", "quit_", "status", "toThrow", "ENVIRONMENT_IS_WEB", "ENVIRONMENT_IS_WORKER", "ENVIRONMENT_IS_NODE", "scriptDirectory", "locateFile", "path", "read_", "readAsync", "readBinary", "setWindowTitle", "fs", "nodePath", "filename", "binary", "isFileURI", "ret", "onload", "onerror", "err", "data", "url", "xhr", "title", "out", "wasmBinary", "noExitRuntime", "abort", "wasmMemory", "ABORT", "EXITSTATUS", "HEAP8", "HEAPU8", "HEAP16", "HEAPU16", "HEAP32", "HEAPU32", "HEAPF32", "HEAPF64", "updateMemoryViews", "b", "wasmTable", "__ATPRERUN__", "__ATINIT__", "__ATPOSTRUN__", "runtimeInitialized", "preRun", "addOnPreRun", "callRuntimeCallbacks", "initRuntime", "postRun", "addOnPostRun", "cb", "addOnInit", "runDependencies", "runDependencyWatcher", "dependenciesFulfilled", "addRunDependency", "id", "removeRunDependency", "callback", "what", "e", "dataURIPrefix", "isDataURI", "wasmBinaryFile", "getBinarySync", "file", "getBinaryPromise", "binaryFile", "response", "instantiateArrayBuffer", "imports", "receiver", "instance", "reason", "instantiateAsync", "result", "createWasm", "info", "wasmImports", "receiveInstance", "applySignatureConversions", "wasmExports", "receiveInstantiationResult", "callbacks", "exceptionCaught", "exceptionLast", "uncaughtExceptionCount", "___cxa_rethrow", "ptr", "ExceptionInfo", "excPtr", "type", "destructor", "caught", "rethrown", "adjustedPtr", "isPointer", "___cxa_is_pointer_type", "adjusted", "___cxa_throw", "__embind_register_bigint", "primitiveType", "name", "size", "minRange", "maxRange", "embind_init_charCodes", "codes", "i", "embind_charCodes", "readLatin1String", "c", "awaitingDependencies", "registeredTypes", "typeDependencies", "BindingError", "throwBindingError", "message", "InternalError", "throwInternalError", "whenDependentTypesAreResolved", "myTypes", "dependentTypes", "getTypeConverters", "onComplete", "typeConverters", "myTypeConverters", "registerType", "unregisteredTypes", "registered", "dt", "sharedRegisterType", "rawType", "registeredInstance", "options", "GenericWireTypeSize", "__embind_register_bool", "trueValue", "falseValue", "wt", "destructors", "o", "pointer", "ClassHandle_isAliasOf", "other", "ClassHandle", "leftClass", "left", "rightClass", "right", "shallowCopyInternalPointer", "throwInstanceAlreadyDeleted", "obj", "getInstanceTypeName", "handle", "finalizationRegistry", "detachFinalizer", "runDestructor", "$$", "releaseClassHandle", "toDelete", "downcastPointer", "ptrClass", "desiredClass", "rv", "registeredPointers", "getInheritedInstanceCount", "registeredInstances", "getLiveInheritedInstances", "k", "deletionQueue", "flushPendingDeletes", "delayFunction", "setDelayFunction", "fn", "init_embind", "getBasestPointer", "class_", "getInheritedInstance", "makeClassHandle", "prototype", "record", "hasSmartPtrType", "hasSmartPtr", "attachFinalizer", "RegisteredPointer_fromWireType", "rawPointer", "makeDefaultHandle", "actualType", "registeredPointerRecord", "toType", "dp", "ClassHandle_clone", "clone", "ClassHandle_delete", "ClassHandle_isDeleted", "ClassHandle_deleteLater", "init_ClassHandle", "char_0", "char_9", "makeLegalFunctionName", "f", "createNamedFunction", "body", "ensureOverloadTable", "proto", "methodName", "humanName", "prevFunc", "exposePublicSymbol", "value", "numArguments", "RegisteredClass", "constructor", "instancePrototype", "rawDestructor", "baseClass", "getActualType", "upcast", "downcast", "upcastPointer", "constNoSmartPtrRawPointerToWireType", "embindRepr", "handleClass", "genericPointerToWireType", "clonedHandle", "Emval", "nonConstNoSmartPtrRawPointerToWireType", "readPointer", "RegisteredPointer_getPointee", "RegisteredPointer_destructor", "RegisteredPointer_deleteObject", "init_RegisteredPointer", "RegisteredPointer", "registeredClass", "isReference", "isConst", "isSmartPointer", "pointeeType", "sharingPolicy", "rawGetPointee", "rawConstructor", "rawShare", "replacePublicSymbol", "dynCallLegacy", "sig", "args", "wasmTableMirror", "getWasmTableEntry", "funcPtr", "func", "dynCall", "rtn", "getDynCaller", "argCache", "embind__requireFunction", "signature", "rawFunction", "makeDynCaller", "fp", "extendError", "baseErrorType", "errorName", "errorClass", "stack", "UnboundTypeError", "getTypeName", "___getTypeName", "_free", "throwUnboundTypeError", "types", "unboundTypes", "seen", "visit", "__embind_register_class", "rawPointerType", "rawConstPointerType", "baseClassRawType", "getActualTypeSignature", "upcastSignature", "downcastSignature", "destructorSignature", "legalFunctionName", "base", "basePrototype", "referenceConverter", "pointerConverter", "constPointerConverter", "heap32VectorToArray", "count", "firstElement", "array", "runDestructors", "del", "newFunc", "argumentList", "dummy", "r", "craftInvokerFunction", "argTypes", "classType", "cppInvokerFunc", "cppTargetFunc", "isAsync", "argCount", "isClassMethodFunc", "needsDestructorStack", "returns", "argsList", "argsListWired", "invokerFnBody", "dtorStack", "args1", "args2", "paramName", "__embind_register_class_constructor", "rawClassType", "rawArgTypesAddr", "invokerSignature", "invoker", "rawArgTypes", "__embind_register_class_function", "rawInvoker", "context", "isPureVirtual", "unboundTypesHandler", "method", "memberFunction", "handleAllocatorInit", "HandleAllocator", "emval_handles", "__emval_decref", "count_emval_handles", "init_emval", "simpleReadValueFromPointer", "__embind_register_emval", "enumReadValueFromPointer", "width", "signed", "__embind_register_enum", "isSigned", "ctor", "requireRegisteredType", "impl", "__embind_register_enum_value", "rawEnumType", "enumValue", "enumType", "Enum", "Value", "v", "floatReadValueFromPointer", "__embind_register_float", "__embind_register_function", "invokerArgsArray", "integerReadValueFromPointer", "__embind_register_integer", "fromWireType", "bitshift", "isUnsignedType", "checkAssertions", "toTypeName", "toWireType", "__embind_register_memory_view", "dataTypeIndex", "typeMapping", "TA", "decodeMemoryView", "stringToUTF8Array", "str", "heap", "outIdx", "maxBytesToWrite", "startIdx", "endIdx", "u1", "stringToUTF8", "outPtr", "lengthBytesUTF8", "len", "UTF8Decoder", "UTF8ArrayToString", "heapOrArray", "idx", "maxBytesToRead", "endPtr", "u0", "u2", "ch", "UTF8ToString", "__embind_register_std_string", "stdStringIsUTF8", "length", "payload", "decodeStartPtr", "currentBytePtr", "maxRead", "stringSegment", "a", "valueIsOfTypeString", "_malloc", "charCode", "UTF16Decoder", "UTF16ToString", "maxIdx", "codeUnit", "stringToUTF16", "startPtr", "numCharsToWrite", "lengthBytesUTF16", "UTF32ToString", "utf32", "stringToUTF32", "trailSurrogate", "lengthBytesUTF32", "__embind_register_std_wstring", "charSize", "decodeString", "encodeString", "getHeap", "lengthBytesUTF", "shift", "HEAP", "maxReadBytes", "__embind_register_void", "__emval_incref", "__emval_take_value", "arg", "_abort", "_emscripten_memcpy_big", "dest", "src", "num", "getHeapMax", "growMemory", "pages", "_emscripten_resize_heap", "requestedSize", "oldSize", "maxHeapSize", "alignUp", "x", "multiple", "cutDown", "overGrownHeapSize", "newSize", "replacement", "___wasm_call_ctors", "a0", "__embind_initialize_bindings", "___errno_location", "makeWrapper_pp", "makeWrapper_p", "calledRun", "runCaller", "run", "doRun", "import_wasm", "geoda", "geodaAny", "wasmInstancePromise", "initWASM", "resetWASM", "wasmInstance", "instance", "setWASM", "getWASM", "getPolygonCollection", "features", "wasm", "fixPolygon", "convertToUTM", "ptIndex", "xs", "ys", "parts", "holes", "sizes", "handlePolygonRing", "polygon", "numParts", "j", "m", "ring", "k", "npts", "pt", "i", "n", "feat", "poly", "getLineCollection", "handleLineSegment", "lineSeg", "validLine", "getPointCollection", "handlePoint", "point", "isValid", "getPointCollectionFromLatLng", "lat", "lng", "start", "end", "getGeometryCollection", "input", "geomType", "getGeojsonPolygon", "numPoints", "numExtRings", "multiPoly", "polyIndex", "coordinates", "getCentroids", "polygons", "wasm", "initWASM", "geodaPolys", "getPolygonCollection", "coords", "numPoints", "centroids", "i", "getCentroid", "feature", "getWASM", "geomType", "geom", "getLineCollection", "getPointCollection", "getGeojsonCentroids", "features", "result", "nFeatures", "validIndex", "validFeatures", "feat", "featureGeomType", "n", "DistanceUnit", "getDistanceThresholds", "distanceUnit", "geometries", "latLngArrays", "n", "minDistanceThreshold", "suggestedDistanceThreshold", "maxDistanceThreshold", "wasmInstance", "initWASM", "geomCollection", "getGeometryCollection", "result", "getDistanceBasedNeighbors", "distanceThreshold", "neighbors", "i", "nbrs", "nbrIndices", "j", "nbrSize", "mileToMeters", "lengthToMeters", "distance", "unit", "mileToMeters", "getBuffersSync", "features", "bufferDistance", "distanceUnit", "pointsPerCircle", "wasmInstance", "nFeatures", "result", "wasm", "getWASM", "validIndex", "validFeatures", "geomType", "i", "feat", "featureGeomType", "convertToUTM", "geom", "getPolygonCollection", "getLineCollection", "getPointCollection", "dist", "lengthToMeters", "n", "idx", "bufferPoly", "bufferGeojson", "getGeojsonPolygon", "getBufferSync", "feature", "SpatialJoinType", "spatialJoin", "source", "join", "spatialJoinOperation", "wasmInstance", "initWASM", "runSpatialJoin", "start", "end", "sourceGeometryCollection", "getGeometryCollection", "joinGeometryCollection", "spatialJoinOp", "result", "joinRelation", "i", "n", "rightIndices", "relation", "j", "m", "prepareParallelSpatialJoin", "source", "join", "spatialJoinOperation", "workerCount", "taskDataArray", "sourceSize", "joinSize", "divideRight", "bigSize", "workChunk", "remainder", "indexTable", "initSpatialJoinTasks", "taskIndex", "start", "end", "prepareJoinDataset", "i", "taskData", "dataset", "noSlicing", "processJoinResultsFromWorker", "result", "taskId", "joinRelation", "n", "rightIndices", "j", "m", "DEFAULT_WORKER_COUNT", "parallelSpatialJoin", "source", "join", "spatialJoinOperation", "options", "workerCount", "preparedData", "prepareParallelSpatialJoin", "sourceSize", "divideRight", "indexTable", "taskDataArray", "joinRelation", "i", "runningWorkers", "joinResolve", "onTaskDone", "event", "result", "taskId", "processJoinResultsFromWorker", "processSpatialJoinTasks", "resolve", "taskData", "instance", "spatialMerge", "polygons", "wasmInstance", "initWASM", "spatialMergeSync", "wasm", "getWASM", "polygonCollection", "getPolygonCollection", "poly", "getGeojsonPolygon", "spatialCount", "polygons", "points", "n", "counts", "wasmInstance", "initWASM", "polygonCollection", "getPolygonCollection", "pointCollection", "getPointCollection", "getPointCollectionFromLatLng", "result", "i", "getNearestNeighbors", "k", "geometries", "latLngArrays", "n", "neighbors", "wasmInstance", "initWASM", "geomCollection", "getGeometryCollection", "result", "i", "nbrs", "nbrIndices", "j", "nbrSize", "localMoran", "data", "neighbors", "permutation", "wasm", "initWASM", "n", "wasmData", "i", "wasmNeighbors", "nbrs", "wasmNeighborIndices", "j", "numNbrs", "result", "vecDoubleToNumber"]
}
